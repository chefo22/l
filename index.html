<!doctype html>
<html lang="es">

<head>
    <script>
        (function() {
            // La clave m√°s simple que indica que el usuario ya ha pasado por el proceso de activaci√≥n/uso.
            // Si la clave 'darkMode' existe, el usuario est√° verificado.
            const CLAVE_DE_ACTIVACION = 'darkMode'; 
            
            // Otras claves que indican que el usuario ya ha estado usando la web.
            const INDICADORES_ADICIONALES = [
                'favorites', 
                'channelHistory', 
                'primaryColor',
                'channelRatings'
            ];
            
            let accesoConcedido = false;

            // Paso 1: Comprobar la clave de activaci√≥n/uso b√°sico
            if (localStorage.getItem(CLAVE_DE_ACTIVACION) !== null) {
                accesoConcedido = true;
            } else {
                // Paso 2: Si la clave de activaci√≥n no existe, comprobar si existen otras claves
                // que indican que el usuario es existente (por si se borr√≥ solo 'darkMode').
                for (const key of INDICADORES_ADICIONALES) {
                    if (localStorage.getItem(key) !== null) {
                        accesoConcedido = true;
                        break; 
                    }
                }
            }

            // Si no se encuentra NING√öN indicador, se bloquea.
            if (!accesoConcedido) {
                // Mostrar la nueva p√°gina de error para nuevos usuarios.
                document.documentElement.innerHTML = `
                    <!DOCTYPE html>
                    <html lang="es">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>404 - No Encontrado</title>
                        <style>
                            /* Estilos Generales */
                            body {
                                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
                                background-color: #f7f7f7; 
                                color: #333; 
                                margin: 0;
                                padding: 0;
                                display: flex;
                                justify-content: center; 
                                align-items: flex-start; 
                                min-height: 100vh;
                                padding-top: 15vh; 
                            }

                            /* Estilo del Contenedor Principal (Error Box) */
                            .error-container {
                                text-align: center;
                                max-width: 90%;
                            }

                            /* Estilo del Encabezado (404) */
                            .error-container h1 {
                                font-size: 3.5em; 
                                font-weight: 600; 
                                margin-bottom: 0.2em;
                                color: #444;
                            }

                            /* Estilo del T√≠tulo del Error */
                            .error-container h2 {
                                font-size: 1.2em;
                                font-weight: 400; 
                                margin-top: 0;
                                color: #666; 
                            }

                            /* Estilo del P√°rrafo de Instrucci√≥n */
                            .error-container p {
                                font-size: 1em;
                                line-height: 1.5;
                                color: #777;
                                margin-bottom: 2em;
                                max-width: 450px; 
                                margin-left: auto;
                                margin-right: auto;
                            }

                            /* Estilo del Enlace (Documentaci√≥n) */
                            .error-container a {
                                color: #0366d6; 
                                text-decoration: none; 
                            }

                            .error-container a:hover {
                                text-decoration: underline;
                            }

                            /* Estilo de la Secci√≥n de Estado (L√≠nea de abajo) */
                            .status-links {
                                margin-top: 3em;
                                display: flex;
                                justify-content: center;
                                align-items: center;
                                gap: 1.5em;
                                font-size: 0.9em;
                                color: #999;
                            }

                            .status-links a {
                                color: #999;
                            }

                            /* Estilo para el Separador Central */
                            .separator {
                                width: 16px;
                                height: 16px;
                                border: 2px solid #ccc; 
                                border-top: 2px solid transparent; 
                                border-radius: 50%;
                            }

                            @keyframes spin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                        </style>
                    </head>
                    <body>

                        <div class="error-container">
                            <h1>404</h1>

                            <h2>There isn't a GitHub Pages site here.</h2>

                            <p>
                                If you're trying to publish one, 
                                <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages" target="_blank">read the full documentation</a>
                                to learn how to set up GitHub Pages for your repository, organization, or user account.
                            </p>
                            
                            <div class="status-links">
                                <a href="https://www.githubstatus.com/" target="_blank">GitHub Status</a>
                                
                                <div class="separator"></div>
                                
                                <a href="https://twitter.com/githubstatus" target="_blank">@githubstatus</a>
                            </div>
                        </div>
                        
                    </body>
                    </html>
                `;
                // Detener completamente la ejecuci√≥n del resto del c√≥digo de la p√°gina
                window.stop(); 
            }
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width,initial-scale=1.0,maximum-scale=1.6,user-scalable=no">
    <title>TV</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.8em%22 font-size=%2285%22>üì∫</text></svg>">
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: rgba(37, 99, 235, 0.1);
            --primary-dark: #1e50c7;
            --bg-light: #f1f5f9;
            --card-bg: #ffffff;
            --text: #1e293b;
            --border-color: #e2e8f0;
            --white: #ffffff;
            --radius-md: 5px; /* Reducido a la mitad: 10px -> 5px */
            --radius-sm: 3px; /* Reducido a la mitad: 6px -> 3px */
            --shadow-sm: 0 0.5px 1.5px rgba(0, 0, 0, 0.1); /* Reducido a la mitad */
            --primary-rgb: 37, 99, 235;
            --secondary: #000000;
            --success: #4cc9f0;
            --warning: #f8961e;
            --info: #4895ef;
            --movistar-blue: #0085C1;
            --eurosport-blue: #5e17eb;
            --dazn-black: #000000;
            --f1-red: #ff3535;
            --action-red: #ff544d;
            --cinema-red: #fa3732;
            --sports-green: #11a45b;
            --vamos-green: #1fc23d;
            --copadelrey-green: #449653;
            --champions-teal: #52c29c;
            --liga-teal: #21ffb8;
            --hypermotion-cyan: #04d2d7;
            --golf-teal: #4ee1b0;
            --eurosport-number-red: #ff3535;
            --plus-blue: #3399ff;
            --western-red: #e60000;
            --documentary-purple: #a06cf5;
            --originals-blue: #3985b0;
            --ellas-green: #35fd9b;
            --series-orange: #ff8c1f;
            --gist-source-color: #2d077d;
            --elcano-source-color: #7d070e;
            --special-gist-color: #9c27b0;
            --events-source-color: #074f7d;
            --shickat-badge: #077b3b;
            --era-source-color: #f55d3e;
            --channel-name-color: #888888;
            --player-bg: black;
            --channel-number-color: #4b5563
        }

        body.dark-mode {
            --bg-light: #131313;
            --card-bg: #282828;
            --text: #f8fafc;
            --border-color: #555555;
            --shadow-sm: 0 0.5px 1.5px rgba(0, 0, 0, 0.3); /* Reducido a la mitad */
            --primary-light: rgba(var(--primary-rgb), 0.2);
            --channel-name-color: #e2e2ff;
            --player-bg: #1e1e1e;
            --channel-number-color: #b0b0b0
        }

        body {
            /* Aplicamos los estilos de TV Mode al cuerpo por defecto */
            background: #151515 !important;
            color: #e0e0e0 !important;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            transition: all .3s
        }

        /* Eliminamos las clases de la interfaz normal (main-container, search-filters, filter-buttons, etc.) */

        .channel-card {
            /* No se usa en TV Mode, se mantiene por si se usa en alg√∫n renderizado de prueba */
            min-width: 140px; /* Reducido a la mitad: 280px -> 140px */
            max-width: 140px; /* Reducido a la mitad: 280px -> 140px */
            flex: 0 0 auto;
            scroll-snap-align: start;
            background: var(--card-bg);
            border: 0.5px solid var(--border-color); /* Reducido a la mitad */
            border-radius: var(--radius-md);
            padding: 0.25rem 0.5rem 0.5rem 0.5rem; /* Reducido a la mitad */
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: all .2s;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center
        }

        /* ESTILOS DE NOTIFICACIONES (RESTAURADOS Y AJUSTADOS AL MODO TV) */
        .status-message {
            text-align: center;
            padding: 0.25rem; /* Reducido a la mitad: .5rem -> .25rem */
            font-size: .425rem; /* Reducido a la mitad: .85rem -> .425rem */
            background-color: rgba(76, 201, 240, .1);
            border-radius: var(--radius-sm);
            margin-bottom: 0.25rem; /* Reducido a la mitad: .5rem -> .25rem */
            opacity: 1;
            transition: all .5s ease-in-out, margin .5s ease-in-out;
            /* Estilos de centrado para Modo TV */
            margin-left: auto;
            margin-right: auto;
            max-width: 400px; /* Reducido a la mitad: 800px -> 400px */
            width: 90%;
            box-shadow: var(--shadow-sm);
            z-index: 50;
        }

        .status-message.hide {
            opacity: 0;
            transform: translateY(-10px); /* Reducido a la mitad: -20px -> -10px */
            pointer-events: none;
            margin-bottom: 0
        }

        .status-message.success {
            color: var(--primary);
            background-color: var(--primary-light)
        }

        .status-message.info {
            color: var(--primary);
            background-color: var(--primary-light)
        }

        .status-message.error {
            color: var(--text);
            background-color: rgba(247, 37, 133, .2);
        }

        .status-message.warning {
            color: var(--warning);
            background-color: rgba(248, 150, 30, .1)
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, .5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001
        }

        .modal--active {
            display: flex
        }

        .modal__content {
            background: var(--card-bg);
            border-radius: var(--radius-md);
            padding: 0.6rem; /* Reducido a la mitad: 1.2rem -> 0.6rem */
            width: 90%;
            max-width: 175px; /* Reducido a la mitad: 350px -> 175px */
            box-shadow: var(--shadow-sm)
        }

        .modal__title {
            margin-bottom: 0.4rem; /* Reducido a la mitad: .8rem -> .4rem */
            color: var(--text);
            font-size: 0.55rem; /* Reducido a la mitad: 1.1rem -> 0.55rem */
            display: flex;
            align-items: center;
            gap: 4px; /* Reducido a la mitad: 8px -> 4px */
        }

        .modal__actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.3rem; /* Reducido a la mitad: .6rem -> .3rem */
            margin-top: 0.5rem; /* Reducido a la mitad: 1rem -> .5rem */
        }

        .modal__btn {
            padding: 0.25rem 0.4rem; /* Reducido a la mitad: .5rem .8rem -> .25rem .4rem */
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.45rem; /* Reducido a la mitad: .9rem -> .45rem */
            transition: all .2s
        }

        .modal__btn--primary {
            background: var(--primary);
            color: #fff
        }

        .modal__btn--primary:hover {
            background: var(--primary-dark)
        }

        .settings-section {
            margin-bottom: 0.6rem; /* Reducido a la mitad: 1.2rem -> 0.6rem */
            padding-bottom: 0.5rem; /* Reducido a la mitad: 1rem -> 0.5rem */
            border-bottom: 0.5px solid var(--border-color); /* Reducido a la mitad */
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0
        }

        .settings-section__title {
            font-size: 0.45rem; /* Reducido a la mitad: .9rem -> .45rem */
            color: var(--primary);
            margin-bottom: 0.4rem; /* Reducido a la mitad: .8rem -> .4rem */
            display: flex;
            align-items: center;
            gap: 4px; /* Reducido a la mitad: 8px -> 4px */
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem; /* Reducido a la mitad: .8rem -> .4rem */
            padding: 0.25rem; /* Reducido a la mitad: .5rem -> .25rem */
            border-radius: var(--radius-sm);
            transition: background .2s
        }

        .settings-item:hover {
            background: var(--primary-light)
        }

        .settings-item__info {
            display: flex;
            align-items: center;
            gap: 6px; /* Reducido a la mitad: 12px -> 6px */
            flex: 1
        }

        .settings-icon {
            font-size: 0.6rem; /* Reducido a la mitad: 1.2rem -> 0.6rem */
        }

        .settings-label {
            font-size: 0.45rem; /* Reducido a la mitad: .9rem -> .45rem */
            color: var(--text);
            font-weight: 500;
            display: block
        }

        .settings-description {
            font-size: 0.375rem; /* Reducido a la mitad: .75rem -> .375rem */
            color: var(--text);
            opacity: .7;
            display: block;
            margin-top: 1px; /* Reducido a la mitad: 2px -> 1px */
        }

        .settings-switch {
            position: relative;
            display: inline-block;
            width: 25px; /* Reducido a la mitad: 50px -> 25px */
            height: 12px; /* Reducido a la mitad: 24px -> 12px */
        }

        .settings-switch input {
            opacity: 0;
            width: 0;
            height: 0
        }

        .settings-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 12px; /* Reducido a la mitad: 24px -> 12px */
        }

        body.dark-mode .settings-slider {
            /* Nuevo: Color del slider inactivo en modo oscuro */
            background-color: #555555;
        }

        .settings-slider:before {
            position: absolute;
            content: "";
            height: 8px; /* Reducido a la mitad: 16px -> 8px */
            /* CORRECCI√ìN: Se fija el ancho y alto del c√≠rculo interior */
            width: 8px; /* Reducido a la mitad: 16px -> 8px */
            left: 2px; /* Reducido a la mitad: 4px -> 2px */
            bottom: 2px; /* Reducido a la mitad: 4px -> 2px */
            background-color: #fff;
            transition: .4s;
            border-radius: 50%
        }

        input:checked+.settings-slider {
            background-color: var(--primary)
        }

        input:checked+.settings-slider:before {
            transform: translateX(13px); /* Reducido a la mitad: 26px -> 13px */
        }
        
        .color-picker {
            display: flex;
            gap: 3px; /* Reducido a la mitad: 6px -> 3px */
        }

        .color-option {
            width: 12px; /* Reducido a la mitad: 24px -> 12px */
            height: 12px; /* Reducido a la mitad: 24px -> 12px */
            border-radius: 50%;
            border: 1px solid transparent; /* Reducido a la mitad: 2px -> 1px */
            cursor: pointer;
            transition: transform .2s
        }

        .color-option:hover {
            transform: scale(1.1)
        }

        .color-option.active {
            border-color: var(--text);
            transform: scale(1.1)
        }

        /* Mantenemos el ajuste de color de texto en modal para que se vea en modo oscuro */
        .modal__title, .channel-option-name, .settings-label {
            color: var(--text) !important;
        }
        .settings-description {
            color: var(--text) !important;
            opacity: .7 !important;
        }
        .settings-section__title {
            color: var(--primary) !important;
        }
        
        .degradado-comedia {
            background-image: linear-gradient(to right, #ff3c3c, orange);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700
        }

        .copy-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            border: 0.5px solid var(--border-color); /* Reducido a la mitad */
            border-radius: var(--radius-md);
            padding: 0.75rem; /* Reducido a la mitad: 1.5rem -> 0.75rem */
            box-shadow: 0 2px 6px rgba(0, 0, 0, .2); /* Reducido a la mitad */
            z-index: 2000;
            width: 90%;
            max-width: 160px; /* Reducido a la mitad: 320px -> 160px */
            display: none;
            flex-direction: column;
            align-items: center;
            text-align: center;
            animation: fadeIn .3s ease-out
        }

        .copy-modal.active {
            display: flex
        }

        .copy-modal-icon {
            font-size: 1.25rem; /* Reducido a la mitad: 2.5rem -> 1.25rem */
            margin-bottom: 0.4rem; /* Reducido a la mitad: .8rem -> .4rem */
        }

        .copy-modal-text {
            font-size: 0.475rem; /* Reducido a la mitad: .95rem -> .475rem */
            color: var(--text);
            margin-bottom: 0.5rem; /* Reducido a la mitad: 1rem -> .5rem */
        }

        .copy-modal-button {
            padding: 0.3rem 0.6rem; /* Reducido a la mitad: .6rem 1.2rem -> .3rem .6rem */
            background: var(--primary);
            color: #fff;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.45rem; /* Reducido a la mitad: .9rem -> .45rem */
            font-weight: 600;
            transition: background .2s;
            margin-bottom: 0.25rem; /* Reducido a la mitad: .5rem -> .25rem */
        }

        .copy-modal-button:hover {
            background: var(--primary-dark)
        }

        .copy-modal-url {
            background-color: var(--bg-light);
            color: var(--text);
            padding: 0.25rem; /* Reducido a la mitad: .5rem -> .25rem */
            margin-bottom: 0.5rem; /* Reducido a la mitad: 1rem -> .5rem */
            border-radius: var(--radius-sm);
            font-family: monospace;
            word-break: break-all;
            font-size: 0.425rem; /* Reducido a la mitad: .85rem -> .425rem */
            display: block
        }

        body.dark-mode .copy-modal-url {
            background-color: var(--border-color)
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%)
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%)
            }
        }

        .copy-message {
            position: fixed;
            bottom: 10px; /* Reducido a la mitad: 20px -> 10px */
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: #fff;
            padding: 0.3rem 0.6rem; /* Reducido a la mitad: .6rem 1.2rem -> .3rem .6rem */
            border-radius: var(--radius-sm);
            font-size: 0.45rem; /* Reducido a la mitad: .9rem -> .45rem */
            z-index: 2001;
            opacity: 0;
            transition: opacity .4s ease-in-out
        }

        .copy-message.show {
            opacity: 1
        }
        
        .floating-save-button {
            display: none !important;
        }

        .live-time-blink {
            color: var(--primary) !important;
            animation: soft-blink 1.5s infinite ease-in-out;
            font-weight: 700
        }

        @keyframes soft-blink {
            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: .5
            }
        }

        .live-separator {
            display: none;
        }

        .subgroup-title, .subgroup-content {
            display: none !important;
        }

        /* La clase tv-mode-active ya no es necesaria, ya que es el modo por defecto */
        .tv-mode-active {
            background: #151515 !important;
            color: #e0e0e0 !important;
        }

        /* INICIO DE LOS CAMBIOS (Modo TV) */

        #tvSidebar {
            background: #111111;
            color: #e0e0e0;
            padding: 0.75rem 0.25rem; /* Reducido a la mitad: 1.5rem 0.5rem -> 0.75rem 0.25rem */
            position: fixed;
            left: 0;
            top: 0;
            width: 50px; /* Reducido a la mitad: 100px -> 50px */
            height: 100vh;
            overflow-y: auto;
            border-right: 0.5px solid #383838; /* Reducido a la mitad */
            z-index: 100;
            display: flex;
            flex-direction: column;
            /* CAMBIO CLAVE: Centrar verticalmente el contenido */
            justify-content: center;
        }

        #tvSidebar .sidebar-logo {
            font-size: 0.5rem; /* Reducido a la mitad: 1rem -> 0.5rem */
            font-weight: 800;
            color: white;
            margin-bottom: 1rem; /* Reducido a la mitad: 2rem -> 1rem */
            padding-left: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #tvSidebar input#tvSearch {
            width: 100%;
            padding: 4px 2.5px; /* Reducido a la mitad: 8px 5px -> 4px 2.5px */
            border-radius: 3px; /* Reducido a la mitad: 6px -> 3px */
            font-size: 0.4rem; /* Reducido a la mitad: 0.8rem -> 0.4rem */
            box-sizing: border-box;
            background-color: #383838;
            color: #ffffff;
            border: 0.5px solid #555555; /* Reducido a la mitad */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4); /* Reducido a la mitad */
        }
        
        #tvSidebar input#tvSearch:focus {
            outline: none;
            border-color: var(--primary);
        }

        #tvSidebar .tv-nav-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 4px 0; /* Reducido a la mitad: 8px 0 -> 4px 0 */
            border-radius: 3px; /* Reducido a la mitad: 6px -> 3px */
            color: #e0e0e0;
            text-decoration: none;
            font-weight: 600;
            transition: background-color 0.2s;
            text-align: center;
            font-size: 0.375rem; /* Reducido a la mitad: 0.75rem -> 0.375rem */
            line-height: 1.1;
        }

        #tvSidebar .tv-nav-link.brand-filter {
            padding: 2.5px 0; /* Reducido a la mitad: 5px 0 -> 2.5px 0 */
            margin: 2.5px auto; /* Reducido a la mitad: 5px auto -> 2.5px auto */
            justify-content: center;
            width: 100%; 
            height: auto; 
        }

        #tvSidebar .tv-nav-link.dazn-filter {
            width: 40px; /* Reducido a la mitad: 80px -> 40px */
            height: 24px; /* Reducido a la mitad: 48px -> 24px */
        }

        #tvSidebar .tv-nav-link.movistar-filter {
            width: 40px; /* Reducido a la mitad: 70px -> 35px */
            height: 16.5px; /* Reducido a la mitad: 33px -> 16.5px */
        }

        #tvSidebar .tv-nav-link.eurosport-filter {
            width: 40px; /* Reducido a la mitad: 80px -> 40px */
            height: 24px; /* Reducido a la mitad: 38px -> 19px */
        }

        #tvSidebar .tv-nav-link.brand-filter img {
            max-width: 90%;
            max-height: 90%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #tvSidebar .tv-nav-link.sport-filter {
            font-size: 0.6rem; /* Reducido a la mitad: 1.2rem -> 0.6rem */
            padding: 5px 0; /* Reducido a la mitad: 10px 0 -> 5px 0 */
            height: 10px; /* Reducido a la mitad: 20px -> 10px */
            width: 20px; /* Reducido a la mitad: 40px -> 20px */
            border-radius: 50%;
            margin: 0 2.5px; /* Reducido a la mitad: 0 5px -> 0 2.5px */
        }

        #tvSportFilters {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            padding: 2.5px 0; /* Reducido a la mitad: 5px 0 -> 2.5px 0 */
            margin-bottom: 0.25rem; /* Reducido a la mitad: 0.5rem -> 0.25rem */
            border-bottom: 0.5px solid #383838; /* Reducido a la mitad */
            border-top: 0.5px solid #383838; /* Reducido a la mitad */
        }

        #tvSidebar .tv-nav-link span {
            margin-right: 0 !important;
            margin-bottom: 1.5px; /* Reducido a la mitad: 3px -> 1.5px */
            font-size: 0.55rem !important; /* Reducido a la mitad: 1.1rem -> 0.55rem */
        }

        #tvSidebar .tv-nav-link:hover,
        #tvSidebar .tv-nav-link.focused-link {
            background-color: #2d2d2d;
        }

        .tv-sidebar-link-focused {
            background-color: var(--primary) !important;
            border: 1px solid white; /* Reducido a la mitad: 2px -> 1px */
            outline-offset: 1px; /* Reducido a la mitad: 2px -> 1px */
            transform: scale(1.02);
        }

        #tvMainContent {
            margin-left: 50px; /* Reducido a la mitad: 100px -> 50px */
            padding: 0.75rem 1.25rem; /* Reducido a la mitad: 1.5rem 2.5rem -> 0.75rem 1.25rem */
            min-height: 100vh;
            background: #151515;
            display: flex; /* Nuevo: Habilitar flexbox */
            flex-direction: column; /* Nuevo: Apilar elementos */
        }

        #tvSidebar button#settingsModeBtn {
            width: 20px; /* Reducido a la mitad: 40px -> 20px */
            height: 20px; /* Reducido a la mitad: 40px -> 20px */
            padding: 0;
            font-size: 0.6rem; /* Reducido a la mitad: 1.2rem -> 0.6rem */
            background-color: #383838;
            color: #e0e0e0;
            border: none;
            border-radius: 50%;
            margin: 0.25rem auto; /* Reducido a la mitad: 0.5rem auto -> 0.25rem auto */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #tvSidebar button#settingsModeBtn:hover,
        #tvSidebar button#settingsModeBtn.tv-sidebar-link-focused {
            background-color: var(--primary) !important;
            border: 1px solid white; /* Reducido a la mitad: 2px -> 1px */
            outline-offset: 1px; /* Reducido a la mitad: 2px -> 1px */
            transform: scale(1.1);
        }
        
        #tvBottomNav {
            padding: 0 2.5px; /* Reducido a la mitad: 0 5px -> 0 2.5px */
            margin-top: 0.5rem; /* Reducido a la mitad: 1rem -> 0.5rem */
        }
        
        .tv-card {
            min-width: 150px; /* Reducido a la mitad: 300px -> 150px */
            max-width: 150px; /* Reducido a la mitad: 300px -> 150px */
            height: 84.5px; /* Reducido a la mitad: 169px -> 84.5px */
            border-radius: 6px; /* Reducido a la mitad: 12px -> 6px */
            background: #2d2d2d;
            border: 1px solid transparent; /* Reducido a la mitad: 2px -> 1px */
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: flex-start;
            padding: 5px 0; /* Reducido a la mitad: 10px 0 -> 5px 0 */
            cursor: pointer;
            transition: transform 0.3s ease-in-out, border-color 0.3s ease-in-out;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 2px 7.5px rgba(0, 0, 0, 0.4); /* Reducido a la mitad */
        }

        .channel-card--logo-img {
            background-size: 80% !important;
            background-position: center !important;
            background-color: #222222 !important;
        }

        .tv-card-focused {
            transform: scale(1.05);
            border-color: var(--primary) !important;
            box-shadow: 0 4px 10px rgba(var(--primary-rgb), 0.5); /* Reducido a la mitad */
        }

        .tv-channels-grid {
            display: flex;
            flex-direction: column;
            gap: 1.25rem; /* Reducido a la mitad: 2.5rem -> 1.25rem */
            flex-grow: 1; /* Nuevo: Asegura que la cuadr√≠cula ocupe el espacio restante */
            min-height: 0; /* Fix para flex-grow en algunos navegadores */
            justify-content: flex-start; /* Por defecto, alinear arriba */
        }

        .tv-group {
            padding: 0;
            margin-bottom: 0;
        }

        .tv-group-header {
            padding: 0 0 0.4rem 0; /* Reducido a la mitad: 0.8rem -> 0.4rem */
            display: flex;
            align-items: center;
        }

        .tv-group-title {
            font-size: 0.75rem; /* Reducido a la mitad: 1.5rem -> 0.75rem */
            font-weight: 700;
            color: #e0e0e0;
            border-left: 2px solid var(--primary); /* Reducido a la mitad: 4px -> 2px */
            padding-left: 7.5px; /* Reducido a la mitad: 15px -> 7.5px */
            width: 100%;
            margin-top: 0; 
        }

        .tv-date-header {
            font-size: 0.9rem; /* Reducido a la mitad: 1.8rem -> 0.9rem */
            font-weight: 800;
            color: #e0e0e0;
            margin-top: 1rem; /* Reducido a la mitad: 2rem -> 1rem */
            margin-bottom: 0.25rem; /* Reducido a la mitad: 0.5rem -> 0.25rem */
            padding-left: 0;
            width: 100%;
        }
        
        .tv-date-header:first-of-type {
            margin-top: 0;
        }


        .tv-subgroup-content {
            display: flex;
            gap: 0.75rem; /* Reducido a la mitad: 1.5rem -> 0.75rem */
            padding: 0.25rem 0; /* Reducido a la mitad: 0.5rem 0 -> 0.25rem 0 */
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            scroll-snap-type: x mandatory;
        }

        .tv-subgroup-content::-webkit-scrollbar {
            height: 0;
            display: none;
        }

        .modal__content {
            max-width: 225px; /* Reducido a la mitad: 450px -> 225px */
        }

        .channel-option-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px; /* Reducido a la mitad: 10px -> 5px */
            margin-bottom: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            border-radius: var(--radius-sm);
            background: #343434; 
            cursor: pointer;
            transition: background-color 0.2s;
            border: 0.5px solid #444444; /* Reducido a la mitad */
        }

        .channel-option-item:hover {
            background: #333333;
            border-color: var(--primary);
        }

        .channel-option-name {
            font-weight: 600;
            color: var(--text);
            flex-grow: 1;
            margin-left: 5px; /* Reducido a la mitad: 10px -> 5px */
            font-size: 0.45rem; /* A√±adido: Se reduce el tama√±o de fuente */
        }
        
        .channel-option-name-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            font-weight: 600;
            color: var(--text);
        }

        .last-viewed-indicator {
            margin-left: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            margin-right: 5px; /* Reducido a la mitad: 10px -> 5px */
            font-size: 0.55rem; /* Reducido a la mitad: 1.1rem -> 0.55rem */
            color: var(--primary);
            font-weight: 700;
        }
        
        .channel-option-details {
            font-size: 0.4rem; /* A√±adido: Se reduce el tama√±o de fuente */
            display: flex;
            align-items: center;
            gap: 3px; /* A√±adido: Espacio reducido */
        }

        .tv-link-button {
            position: absolute;
            bottom: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            right: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            width: 15px; /* Reducido a la mitad: 30px -> 15px */
            height: 15px; /* Reducido a la mitad: 30px -> 15px */
            border-radius: 50%;
            background-color: rgba(120, 120, 120, 0.15);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.45rem; /* Reducido a la mitad: 0.9rem -> 0.45rem */
            box-shadow: 0 0.5px 2px rgba(0, 0, 0, 0.4); /* Reducido a la mitad */
            z-index: 50;
            transition: transform 0.2s, background-color 0.2s;
        }

        .tv-link-button:hover,
        .tv-link-button-focused {
            background-color: var(--primary);
            transform: scale(1.05);
        }
        
        .favorite-toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-right: 2.5px; /* Reducido a la mitad: 5px -> 2.5px */
            font-size: 0.6rem; /* Reducido a la mitad: 1.2rem -> 0.6rem */
            color: #FFD700;
            transition: transform 0.1s ease;
            display: flex;
            align-items: center;
        }
        
        .favorite-toggle-btn:hover {
            transform: scale(1.1);
        }
        
        .favorite-toggle-btn.is-not-favorite {
            color: var(--channel-name-color);
            opacity: 0.7;
            font-weight: 400;
        }
        
        /* ESTILOS PARA EL MENSAJE DE NO RESULTADOS */
        .no-results-container { /* Nuevo contenedor para centrar */
            display: flex;
            justify-content: center; /* Centrar horizontalmente */
            align-items: center; /* Centrar verticalmente */
            flex-grow: 1;
            width: 100%;
            height: 100%; /* Ocupar el espacio disponible */
        }
        
        .no-results {
            text-align: center;
            padding: 1rem; /* Reducido a la mitad: 2rem -> 1rem */
            background: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin: auto; /* Centrado dentro del no-results-container */
            max-width: 400px; /* Reducido a la mitad: 800px -> 400px */
            width: 90%;
        }

        .no-results-icon {
            font-size: 1.5rem; /* Reducido a la mitad: 3rem -> 1.5rem */
            margin-bottom: 0.5rem; /* Reducido a la mitad: 1rem -> 0.5rem */
            opacity: .5;
            color: #666;
        }

        .no-results-text {
            font-size: 0.55rem; /* Reducido a la mitad: 1.1rem -> 0.55rem */
            color: var(--text);
            margin-bottom: 0.25rem; /* Reducido a la mitad: .5rem -> .25rem */
            font-weight: 600;
        }

        .no-results-hint {
            font-size: 0.45rem; /* Reducido a la mitad: .9rem -> .45rem */
            color: var(--text);
            opacity: .7;
        }

        /* Para modo oscuro */
        body.dark-mode .no-results {
            background: #222222;
            border: 0.5px solid #383838; /* Reducido a la mitad */
            box-shadow: none; /* Mantener sin shadow espec√≠fico de card en modo oscuro TV */
        }

        body.dark-mode .no-results-icon {
            color: #666;
            opacity: 1;
        }

        body.dark-mode .no-results-text {
            color: #e0e0e0;
        }

        body.dark-mode .no-results-hint {
            color: #aaa;
        }
        
        /* ESTILO NUEVO: Ocultar bot√≥n '+' en modo "Ocultar bot√≥n opciones" */
        body.hide-options-button-active .tv-card .tv-link-button {
            visibility: hidden;
            /* Usamos visibility: hidden en lugar de display: none para que el bot√≥n siga siendo accesible por eventos del rat√≥n/teclado si es necesario, 
            aunque en este caso la l√≥gica principal de la card manejar√° el clic. */
        }
        
        /* Ajuste para que tvChannelsGrid ocupe todo el espacio disponible en TVMainContent */
        #tvChannelsGrid.no-channels {
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             height: 100%;
             min-height: 50vh; /* Para que al menos se centre en una parte visible de la pantalla */
             gap: 0;
        }
    </style>
</head>

<body class="tv-mode-active dark-mode">
    <aside id="tvSidebar">
        <div>
            <div style="margin-bottom: 0.5rem; padding: 0 2.5px;">
                <input type="text" id="tvSearch" placeholder="Buscar canal..." tabindex="0">
            </div>
            <nav>
                <ul style="list-style: none; padding: 0; margin: 0;">
                    <li style="margin-bottom: 0.25rem;"><a href="#" class="tv-nav-link" data-filter="all" tabindex="0">
                            <span>üåê</span> Todos </a></li>
                    <li style="margin-bottom: 0.25rem;"><a href="#" class="tv-nav-link" data-filter="live" tabindex="0">
                            <span>üî¥</span> Directo </a></li>
                    <li style="margin-bottom: 0.25rem;"><a href="#" class="tv-nav-link" data-filter="favorites"
                            tabindex="0"> <span>‚≠ê</span>Favoritos </a></li>

                    <li style="margin: 0.25rem 0; border-top: 0.5px solid #383838;"></li> <li style="margin-top: 0.25rem;"><a href="#" class="tv-nav-link brand-filter dazn-filter" data-filter="dazn" tabindex="0"> <img src="https://images.weserv.nl/?url=https%3A%2F%2Fstatic.wikia.nocookie.net%2Flogopedia%2Fimages%2F7%2F7c%2FDAZN.svg%2Frevision%2Flatest%3Fcb%3D20210824163814" alt="DAZN Logo"> </a></li>
                        <li><a href="#" class="tv-nav-link brand-filter movistar-filter" data-filter="m+" tabindex="0">
                        <img src="https://images.weserv.nl/?url=https://static.wikia.nocookie.net/logopedia/images/a/af/Movistar_2025.svg/revision/latest?cb=20251005163444" alt="Movistar+ Logo"> </a></li>
                    <li style="margin-bottom: 0.25rem;"><a href="#" class="tv-nav-link brand-filter eurosport-filter" data-filter="eurosport" tabindex="0"> <img src="https://images.weserv.nl/?url=https://static.wikia.nocookie.net/logopedia/images/9/99/Eurosport_Mobile_Logo.png/revision/latest?cb=20180407080639"> </a></li>

                    <div id="tvSportFilters">
                        <a href="#" class="tv-nav-link sport-filter" data-sport-key="futbol" tabindex="0" title="F√∫tbol">‚öΩ</a>
                        <a href="#" class="tv-nav-link sport-filter" data-sport-key="baloncesto" tabindex="0" title="Baloncesto">üèÄ</a>
                        <a href="#" class="tv-nav-link sport-filter" data-sport-key="tenis" tabindex="0" title="Tenis">üéæ</a>
                        <a href="#" class="tv-nav-link sport-filter" data-sport-key="motorsport" tabindex="0" title="Motorsport">üèÅ</a>
                        <a href="#" class="tv-nav-link sport-filter" data-sport-key="f1" tabindex="0" title="F1">üèéÔ∏è</a>
                    </div>
                    </ul>
            </nav>
        </div>
        <div id="tvBottomNav">
            <button id="settingsModeBtn" tabindex="0"> ‚öôÔ∏è </button>
        </div>
    </aside>
    <main id="tvMainContent">
        <div id="tvStatusMessageContainer" style="margin-bottom: 0.75rem;"></div>
        <h1 style="color: white; margin-top: 0;"></h1>
        <div class="tv-channels-grid" id="tvChannelsGrid"></div>
    </main>


    <div class="modal" id="settingsModal">
        <div class="modal__content">
            <h3 class="modal__title">‚öôÔ∏è Ajustes</h3>
            <div class="settings-section">
                <h4 class="settings-section__title">üì∫ Opciones de Interfaz</h4>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">üñ•Ô∏è</span>
                        <div><span class="settings-label">Pantalla Completa al Clic</span><span class="settings-description">Activa el modo de pantalla completa al hacer clic en cualquier parte de la interfaz.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="fullScreenOnClickCheckbox"><span class="settings-slider"></span></label>
                </div>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">‚ûï</span>
                        <div><span class="settings-label">Ocultar Bot√≥n de Opciones</span><span class="settings-description">Mantiene la funcionalidad del bot√≥n '+' pero lo hace invisible.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="hideOptionsButtonCheckbox"><span class="settings-slider"></span></label>
                </div>
                <p class="settings-description" style="color: var(--text); opacity: 0.7; margin-bottom: 0.5rem;">
                    Esta interfaz est√° optimizada para TV/Mandos. Para escritorio, usa la versi√≥n normal.</p>
            </div>
            <div class="settings-section">
                <h4 class="settings-section__title">üé® Apariencia</h4>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">üåì</span>
                        <div><span class="settings-label">Modo oscuro</span><span class="settings-description">Cambia
                                entre tema claro y oscuro (Solo afecta a los modales).</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="darkModeCheckbox"><span
                            class="settings-slider"></span></label>
                </div>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">üé®</span>
                        <div><span class="settings-label">Color principal</span><span class="settings-description">Elige
                                un color para la interfaz</span></div>
                    </div>
                    <div class="color-picker"><button class="color-option" data-color="#2563eb"
                            style="background:#2563eb"></button><button class="color-option" data-color="#dc2626"
                            style="background:#dc2626"></button><button class="color-option" data-color="#16a34a"
                            style="background:#16a34a"></button><button class="color-option" data-color="#79006f"
                            style="background:#79006f"></button></div>
                </div>
            </div>
            <div class="settings-section">
                <h4 class="settings-section__title">üîß Datos</h4>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">üìÖ</span>
                        <div><span class="settings-label">Ocultar detalles de evento</span><span
                                class="settings-description">Oculta fecha, hora y deporte de los grupos.</span></div>
                    </div><label class="settings-switch"><input type="checkbox" id="hideEventDetailsCheckbox"><span
                            class="settings-slider"></span></label>
                </div>
                <div class="settings-item">
                    <div class="settings-item__info"><span class="settings-icon">‚≠ê</span>
                        <div><span class="settings-label">Restablecer puntuaciones</span><span
                                class="settings-description">Borra la puntuaci√≥n de estabilidad de todos los
                                canales</span></div>
                    </div><button class="modal__btn" onclick="resetRatings()">Reiniciar</button>
                </div>
            </div>
            <div class="modal__actions"><button class="modal__btn modal__btn--primary"
                    id="closeSettingsBtn">Cerrar</button></div>
        </div>
    </div>
    
    <div class="copy-modal" id="copyModal">
        <div class="copy-modal-icon">üîó</div>
        <div class="copy-modal-text">Enlace AceStream a copiar:</div>
        <p id="copyUrlDisplayAceStream" class="copy-modal-url"></p><button class="copy-modal-button"
            id="copyAceStreamBtn" data-format="acestream">Copiar AceStream</button><button
            class="modal__btn modal__btn--cancel" id="cancelCopyBtn">Cancelar</button>
    </div>
    <div class="copy-message" id="copyMessage">URL copiada con √©xito!</div>
    
    <div class="modal" id="tvChannelOptionsModal">
        <div class="modal__content" style="max-width: 225px;">
            <h3 class="modal__title">üì∫ Opciones de Canal <span id="tvModalChannelName"></span></h3>
            <div id="tvModalChannelList" style="max-height: 350px; overflow-y: auto;"></div>
            <div class="modal__actions"><button class="modal__btn modal__btn--primary"
                    id="closeTvOptionsBtn">Cerrar</button></div>
        </div>
    </div>

    <script>
        const state = {
            allChannels: [],
            channelsData: [],
            favorites: JSON.parse(localStorage.getItem('favorites')) || [],
            channelHistory: JSON.parse(localStorage.getItem('channelHistory')) || {},
            currentChannel: null,
            clearButtonClickCount: 0, 
            lastClearButtonClickTime: 0,
            elcanoRetries: 0,
            eventsRetries: 0,
            darkMode: localStorage.getItem('darkMode') !== 'false',
            primaryColor: localStorage.getItem('primaryColor') || '#2563eb',
            channelRatings: JSON.parse(localStorage.getItem('channelRatings')) || {},
            lastChannelPlay: JSON.parse(localStorage.getItem('lastChannelPlay')) || null,
            firstSeen: JSON.parse(localStorage.getItem('firstSeen')) || {},
            hideEventDetails: localStorage.getItem('hideEventDetails') === 'true',
            tvCurrentFilter: localStorage.getItem('tvCurrentFilter') || 'all',
            tvSportFilter: localStorage.getItem('tvSportFilter') || 'all', 
            tvSearchTerm: '',
            tvFocusManager: null,
            playerActive: false,
            lastPlayedByChannel: JSON.parse(localStorage.getItem('lastPlayedByChannel')) || {},
            // NUEVO ESTADO: Controla si la pantalla completa al hacer clic est√° activa
            fullScreenOnClick: localStorage.getItem('fullScreenOnClick') === 'true',
            // NUEVO ESTADO: Ocultar bot√≥n de opciones
            hideOptionsButton: localStorage.getItem('hideOptionsButton') === 'true',
        };
        const LOGOPEDIA_BASE_URL = "https://static.wikia.nocookie.net/logopedia/images/";
        const IMAGE_PROXY_URL = "https://images.weserv.nl/?url=";
        const ERA_URL = "https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/listaplana.txt";
        const championsLeagueImages = {
            'M+ LIGA DE CAMPEONES': '0/05/Liga_de_Campeones_por_Movistar_Plus%2B.svg/revision/latest?cb=20220128151054',
            'M+ COMEDIA': '2/27/Comedia_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230721191930',

            'M+ LIGA DE CAMPEONES 2': '3/33/Liga_de_Campeones_2_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171922',
            'M+ LIGA DE CAMPEONES 3': 'f/f8/Liga_de_Campeones_3_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171923',
            'M+ LIGA DE CAMPEONES 4': '0/0a/Liga_de_Campeones_4_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171811',
            'M+ LIGA DE CAMPEONES 5': 'b/b3/Liga_de_Campeones_5_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171812',
            'M+ LIGA DE CAMPEONES 6': 'd/d8/Liga_de_Campeones_6_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171813',
            'M+ LIGA DE CAMPEONES 7': 'b/bf/Liga_de_Campeones_7_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171814',
            'M+ LIGA DE CAMPEONES 8': 'f/f8/Liga_de_Campeones_3_por_Movistar_Plus%2B.png/revision/latest?cb=20230708171923',
            'M+ DEPORTES': 'd/d7/Deportes_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230721194319',
            'M+ DEPORTES 2': '7/7c/Deportes_2_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230721201028',
            'M+ DEPORTES 3': '4/40/Deportes_3_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230721201007',
            'M+ DEPORTES 4': 'e/eb/Deportes_4_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230721201006',
            'M+ DEPORTES 5': '8/88/Deportes_5_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230721201005',
            'M+ DEPORTES 6': 'd/d1/Deportes_6_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230721201004',
            'M+ LA LIGA': 'c/cd/LaLigaTV_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230704125929',
            'M+ LA LIGA 2': '4/4c/LaLigaTV_2_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230708175335',
            'M+ LA LIGA 3': '0/0e/LaLigaTV_3_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230708175336',
            'M+ LA LIGA 4': 'a/a2/LaLigaTV_4_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230708175337',
            'M+ LA LIGA 5': 'b/ba/LaLigaTV_5_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230708175338',
            '‚òÖEUROSPORT 1': 'c/c8/Eurosport_1.svg/revision/latest?cb=20210911124742',
            'M+ PLUS': '0/07/Movistar_Plus%2B.svg/revision/latest?cb=20240116071854',
            'M+ FESTIVAL DE SAN SEBASTI√ÅN': '3/38/M%C3%BAsica_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230801070424',
            'M+ ROMANCE': '4/4d/Suspense_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230801070149',
            'M+ PLUS 2': '1/1f/Movistar_Plus%2B_2_2023.svg/revision/latest/scale-to-width-down/250?cb=20240116072142',
            'LA LIGA HYPERMOTION 3': '2/23/La_Liga_Hypermotion_3.svg/revision/latest/scale-to-width-down/250?cb=20240921160145',
            'M+ ACCI√ìN': 'b/b6/Acci%C3%B3n_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230721192021',
            'M+ CINE ESPA√ëOL': 'd/d2/Cine_Espa%C3%B1ol_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230722062235',
            'M+ CL√ÅSICOS': '2/2f/Cl%C3%A1sicos_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230721192128',
            'M+ DOCUMENTALES': '7/7c/Documentales_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230801070305',
            'M+ DRAMA': '0/0d/Drama_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230721191847',
            'M+ ESTRENOS': '8/88/Estrenos_por_Movistar_Plus%2B_2025.svg/revision/latest?cb=20250128104456',
            'M+ ELLAS': '1/1d/Ellas_Vamos_por_Movistar_Plus%2B.svg/revision/latest?cb=20230728171815',
            'M+ HITS': '3/3c/Hits_por_M%2B.svg/revision/latest?cb=20250128110338', 
            'M+ INDIE': '2/22/Indie_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230801070038',
            'M+ ORIGINALES': '0/09/Originales_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230801070235',
            'DAZN 1 BAR': '8/83/DAZN_2019_logo.svg/revision/latest?cb=20210824002335',
            'DAZN PVV': '2/29/DAZN_PPV.png/revision/latest/scale-to-width-down/250?cb=20230708104557',
            '‚òÖEUROSPORT 2': '0/0d/Eurosport_2_%282015%29.svg/revision/latest?cb=20171209134527',
            'M+ VAMOS': 'b/be/Vamos_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230728170813',
            'LA LIGA HYPERMOTION': 'b/b5/LaLiga_TV_Hypermotion.svg/revision/latest?cb=20230704141115',
            'LA LIGA HYPERMOTION 2': '6/6f/La_Liga_Hypermotion_2.svg/revision/latest/scale-to-width-down/250?cb=20240921151926',
            'M+ GOLF': '2/21/Golf_por_Movistar_Plus%2B_2023.svg/revision/latest?cb=20230721202544',
            'M+ GOLF 2': '5/57/Golf_2_por_Movistar_Plus%2B_2023.png/revision/latest?cb=20230721202546',
            'DAZN F1': 'c/cc/DAZN_F1.svg/revision/latest?cb=20221210225344',
            'DAZN LA LIGA': '1/18/DAZN_LALIGA_2024.svg/revision/latest?cb=20240910115205',
            'DAZN LA LIGA 2': 'f/fa/DAZN_LaLiga_2_2024.svg/revision/latest/scale-to-width-down/250?cb=20240910121150',
            'DAZN 1': '1/18/DAZN_1_2024.svg/revision/latest?cb=20240713213358',
            'DAZN 2': '8/82/DAZN_2_2024.svg/revision/latest?cb=20240713212845',
            'DAZN 3': '0/0f/DAZN_3_2024.svg/revision/latest?cb=20240713212252',
            'DAZN 4': 'f/f7/DAZN_4_2024.svg/revision/latest?cb=20240713211915',
        };

        function getPlaceholderInfo(channelName) {
            const name = channelName.toUpperCase().trim();
            if (championsLeagueImages[name]) {
                let url = championsLeagueImages[name];

                const baseUrl = LOGOPEDIA_BASE_URL;
                if (url.startsWith('https:')) {
                     url = url.substring(baseUrl.length);
                }

                return {
                    url: url,
                    class: 'channel-card--logo-img'
                };
            }
            return null;
        }

        function proxyImage(url) {
            return IMAGE_PROXY_URL + encodeURIComponent(url);
        }
        const PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://cors-anywhere.herokuapp.com/',
            'https://api.codetabs.com/v1/proxy/?quest=',
            'https://proxy-cors-simple.vercel.app/api?url=',
            'https://yacdn.org/proxy/',
            'https://cors-proxy.fringe.co.kr/?'
        ];
        const GIST_URL = "https://gist.githubusercontent.com/Ciento20/f7847e86d06e5011706fa76f2dab90be/raw";
        const ELCANO_URL = 'https://ipfs.io/ipns/elcano.top';
        const EVENTS_URL = 'https://eventos-eight-dun.vercel.app/';
        const SHICKAT_URL = 'https://shickat.me/';
        const BACKUP_KEYS = {
            gist: 'gist_channels_backup',
            elcano: 'elcano_channels_backup',
            events: 'events_channels_backup',
            shickat: 'shickat_channels_backup',
            era: 'era_channels_backup'
        };
        const MAX_RETRIES = 3;
        const BACKUP_EXPIRY_HOURS = 480;
        const HISTORY_EXPIRY_HOURS = 168;

        const TV_BRAND_FILTER_KEYS = ['all', 'live', 'favorites', 'dazn', 'm+', 'eurosport'];
        const TV_SPORT_FILTER_KEYS = ['futbol', 'baloncesto', 'tenis', 'motorsport', 'f1'];

        const OTHER_SUBGROUPS = [
            'LIGA ENDESA',
            'CANAL DE TENIS',
            'SUPERTENNIS',
            'BUNDESLIGA',
            'PRIMERA FEDERACI√ìN',
            '1RFEF',
            'ARAGON TV',
            'BEIN',
            'BT SPORT',
            'CANAL+SPORT',
            'ESPN',
            'ESSPN',
            'SKY',
            'ESPORT 3',
            'FOX',
            'GOL PLAY',
            'REAL MADRID TV',
            'ORANGE TV',
            'RALLY TV',
            'MOTOR',
            'NBA',
            'NFL',
            'PREMIER SPORTS',
            'DISCOVERY CHANNEL',
            'DARK',
            'AMC',
            'LA 1',
            'LA 2',
            'ANTENA 3',
            'Cuatro',
            'Telecinco',
            'LA SEXTA',
            '24 HORAS',
            'TELEDEPORTE',
            'CAZA Y PESCA',
            'CANAL COCINA',
            'DECASA',
            'ONETORO',
            'ZIGGO',
            'XTRM',
            'MIXED TV',
            'DAZN',
            '(DE)',
            '(PL)',
            '(RU)'
        ];

        function normalizeText(text) {
            if (!text) return '';
            return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
        }

        function extractPID(enlace) {
            if (!enlace) return '';
            return enlace.replace('acestream://', '').trim();
        }

        async function hashContent(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        function trackFirstSeen(channelId) {
            if (!state.firstSeen[channelId]) {
                state.firstSeen[channelId] = new Date().getTime();
                localStorage.setItem('firstSeen', JSON.stringify(state.firstSeen));
            }
        }

        function isChannelNew(channelId) {
            const firstSeenTime = state.firstSeen[channelId];
            if (!firstSeenTime) {
                return false;
            }
            const tenMinutesInMs = 10 * 60 * 1000;
            return (new Date().getTime() - firstSeenTime) < tenMinutesInMs;
        }

        function cleanupOldFirstSeenRecords() {
            const oneWeekInMs = 7 * 24 * 60 * 60 * 1000;
            const now = new Date().getTime();
            for (const channelId in state.firstSeen) {
                if ((now - state.firstSeen[channelId]) > oneWeekInMs) {
                    delete state.firstSeen[channelId];
                }
            }
            localStorage.setItem('firstSeen', JSON.stringify(state.firstSeen));
        }

        function toggleFavorite(channelId) {
            const index = state.favorites.indexOf(channelId);
            if (index > -1) {
                state.favorites.splice(index, 1);
            } else {
                state.favorites.push(channelId);
            }
            localStorage.setItem('favorites', JSON.stringify(state.favorites));
            renderTVChannels();
        }

        function toggleDarkMode() {
            state.darkMode = !state.darkMode;
            localStorage.setItem('darkMode', state.darkMode);
            document.body.classList.toggle('dark-mode', state.darkMode);
            document.getElementById('darkModeCheckbox').checked = state.darkMode;
            updatePrimaryLightColor();
        }

        function toggleHideEventDetails() {
            state.hideEventDetails = !state.hideEventDetails;
            localStorage.setItem('hideEventDetails', state.hideEventDetails);
            document.getElementById('hideEventDetailsCheckbox').checked = state.hideEventDetails;
            document.body.classList.toggle('hide-event-details', state.hideEventDetails);
            renderTVChannels();
        }

        // NUEVA FUNCI√ìN: Alterna el estado de Pantalla Completa al Clic
        function toggleFullScreenOnClick() {
            state.fullScreenOnClick = !state.fullScreenOnClick;
            localStorage.setItem('fullScreenOnClick', state.fullScreenOnClick);
            document.getElementById('fullScreenOnClickCheckbox').checked = state.fullScreenOnClick;
        }
        
        // NUEVA FUNCI√ìN: Alterna el estado de Ocultar Bot√≥n de Opciones
        function toggleHideOptionsButton() {
            state.hideOptionsButton = !state.hideOptionsButton;
            localStorage.setItem('hideOptionsButton', state.hideOptionsButton);
            document.getElementById('hideOptionsButtonCheckbox').checked = state.hideOptionsButton;
            // Aplicar/eliminar la clase CSS al body
            document.body.classList.toggle('hide-options-button-active', state.hideOptionsButton);
            renderTVChannels(); // Llama a render para asegurar que se actualicen las tarjetas si fuera necesario.
        }

        // NUEVA FUNCI√ìN: Solicita el modo de pantalla completa
        function requestFullScreen() {
            if (document.fullscreenElement) {
                // Si ya est√° en pantalla completa, no hacer nada o salir (depende del comportamiento deseado)
                return;
            }
            const element = document.documentElement; // Todo el documento
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) { // Firefox
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) { // Chrome, Safari, Opera
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { // IE/Edge
                element.msRequestFullscreen();
            }
        }

        function clearAllTVFilterVisuals() {
            document.querySelectorAll('#tvSidebar .tv-nav-link').forEach(link => {
                link.classList.remove('tv-sidebar-link-focused');
            });
            document.querySelectorAll('#tvBottomNav button').forEach(button => {
                button.classList.remove('tv-sidebar-link-focused');
            });
        }

        function applyTVFilter(filter, type) {
            let updateNeeded = false;

            if (type === 'brand') {
                if (filter === 'all' && state.tvSearchTerm) {
                    state.tvSearchTerm = '';
                    const tvSearchInput = document.getElementById('tvSearch');
                    if (tvSearchInput) {
                        tvSearchInput.value = '';
                    }
                    updateNeeded = true;
                }

                if (state.tvCurrentFilter !== filter) {
                    state.tvCurrentFilter = filter;
                    localStorage.setItem('tvCurrentFilter', filter);
                    updateNeeded = true;
                } else if (filter !== 'all' && filter !== 'live' && filter !== 'favorites') {
                    state.tvCurrentFilter = 'all';
                    localStorage.setItem('tvCurrentFilter', 'all');
                    updateNeeded = true;
                }

                if (state.tvSportFilter !== 'all') {
                    state.tvSportFilter = 'all';
                    localStorage.setItem('tvSportFilter', 'all');
                    updateNeeded = true;
                }
            }

            if (type === 'sport') {
                state.tvSportFilter = state.tvSportFilter === filter ? 'all' : filter;
                localStorage.setItem('tvSportFilter', state.tvSportFilter);
                updateNeeded = true;

                if (state.tvSportFilter !== 'all' && state.tvCurrentFilter !== 'all') {
                    state.tvCurrentFilter = 'all';
                    localStorage.setItem('tvCurrentFilter', 'all');
                }
            }

            if (updateNeeded) {
                renderTVChannels();
            }
        }


        function showStatusMessage(message, type = "info") {
            let statusElement;
            let container;
            
            container = document.getElementById('tvStatusMessageContainer');
            statusElement = container.querySelector(".status-message");
            if (!statusElement) {
                statusElement = document.createElement("div");
                statusElement.className = "status-message";
                container.prepend(statusElement);
            }

            statusElement.textContent = message;
            statusElement.className = `status-message ${type}`;
            statusElement.classList.remove('hide');
            
            if (state.darkMode && type === 'error') {
                 statusElement.style.color = 'var(--text)';
            } else if (state.darkMode && type === 'warning') {
                statusElement.style.color = 'var(--warning)';
            } else if (state.darkMode && (type === 'success' || type === 'info')) {
                statusElement.style.color = 'var(--primary)';
            } else {
                statusElement.style.color = '';
            }


            if (type === "success" || type === "info") {
                setTimeout(() => {
                    statusElement.classList.add('hide');
                    statusElement.addEventListener('transitionend', () => {
                        if (statusElement.classList.contains('hide')) {
                            statusElement.remove();
                        }
                    }, {
                        once: true
                    });
                }, 3000);
            }
        }

        function saveBackup(data, key, contentHash = null) {
            try {
                localStorage.setItem(key, JSON.stringify({
                    timestamp: new Date().getTime(),
                    data,
                    contentHash
                }));
            } catch (e) {
                console.error(`Error al guardar la copia de seguridad para ${key}:`, e);
            }
        }

        function loadBackup(key) {
            try {
                const backupData = localStorage.getItem(key);
                if (backupData) {
                    const {
                        timestamp,
                        data,
                        contentHash
                    } = JSON.parse(backupData);
                    const backupAgeHours = (new Date().getTime() - timestamp) / (1000 * 60 * 60);
                    if (backupAgeHours > BACKUP_EXPIRY_HOURS) {
                        localStorage.removeItem(key);
                        return null;
                    }
                    return { timestamp, data, contentHash }; 
                }
            } catch (e) {
                console.error(`Error al cargar la copia de seguridad para ${key}:`, e);
            }
            return null;
        }

        function mergeChannels(channelsArray) {
            const allChannels = channelsArray;
            const eventChannels = allChannels.filter(channel => channel.source === 'events');
            const otherChannels = allChannels.filter(channel => channel.source !== 'events');
            const eventIds = new Set(eventChannels.map(channel => channel.id));
            const uniqueOtherChannelsMap = new Map();
            const orderedOtherSources = ['elcano', 'shickat', 'era', 'gist'];
            orderedOtherSources.forEach(source => {
                otherChannels.forEach(channel => {
                    if (channel.source === source) {
                        if (!eventIds.has(channel.id)) {
                            if (!uniqueOtherChannelsMap.has(channel.id)) {
                                uniqueOtherChannelsMap.set(channel.id, channel);
                            }
                        }
                    }
                });
            });
            const mergedOtherChannels = Array.from(uniqueOtherChannelsMap.values());
            return eventChannels.concat(mergedOtherChannels);
        }

        function loadAndRenderBackupChannels() {
            let allBackupChannels = [];
            let hasBackup = false;
            for (const key in BACKUP_KEYS) {
                const backup = loadBackup(BACKUP_KEYS[key]);
                if (backup && backup.data) {
                    allBackupChannels = allBackupChannels.concat(backup.data.map(c => ({
                        ...c,
                        source: key,
                        name: c.name || `Canal de ${key.toUpperCase()}`,
                        id: c.id || `${key}_${Math.random()}`,
                        number: (c.id || `${key}_${Math.random()}`).substring(0, 3),
                        displayableName: c.displayableName || c.name
                    })));
                    hasBackup = true;
                }
            }
            if (allBackupChannels.length > 0) {
                const newChannels = mergeChannels(allBackupChannels);
                state.channelsData = newChannels;
                processChannelNames();
                renderTVChannels();
                return true;
            }
            return false;
        }

        async function fetchAndProcessSource(sourceName, url, processor, backupKey) {
            let channels = null;
            let message = '';
            let contentHash = null;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Error al obtener el contenido de la fuente");
                const infoContent = await response.text();
                
                contentHash = await hashContent(infoContent);

                const backup = loadBackup(backupKey);

                if (backup && backup.contentHash === contentHash) {
                    channels = backup.data;
                    message = `Canales de ${sourceName} cargados (Sin cambios).`;
                    console.log(`[${sourceName}] Contenido sin cambios. Usando backup local.`);
                } else {
                    channels = await processor(infoContent);
                    saveBackup(channels, backupKey, contentHash);
                    message = `Canales de ${sourceName} cargados y actualizados.`;
                    console.log(`[${sourceName}] Contenido actualizado o nuevo. Procesado y guardado.`);
                }

            } catch (error) {
                console.error(`Fallo al cargar de ${sourceName}:`, error);
                
                const backup = loadBackup(backupKey);
                if (backup && backup.data) {
                    channels = backup.data;
                    message = `Fallo de ${sourceName}. Mostrando canales del historial.`;
                } else {
                    message = `Fallo de ${sourceName}. Sin historial disponible.`;
                }
            }

            return {
                name: sourceName,
                channels,
                message
            };
        }


        async function loadInitialChannels() {
            const tvChannelsGrid = document.getElementById("tvChannelsGrid");
            
            document.getElementById('tvStatusMessageContainer').innerHTML = '';

            const isShowingBackup = loadAndRenderBackupChannels();
            const temporaryLoadMessage = isShowingBackup ? "Mostrando historial. Obteniendo datos en tiempo real..." : "Cargando datos en tiempo real...";
            showStatusMessage(temporaryLoadMessage, "warning");
            
            const results = await Promise.allSettled([
                fetchAndProcessSource('events', EVENTS_URL, loadEventsSource, BACKUP_KEYS.events),
                fetchAndProcessSource('era', ERA_URL, loadEraChannels, BACKUP_KEYS.era),
                fetchAndProcessSource('gist', GIST_URL, loadGistChannels, BACKUP_KEYS.gist),
                fetchProxyContentAndProcess('shickat', SHICKAT_URL, processShickatData, BACKUP_KEYS.shickat),
                fetchProxyContentAndProcess('elcano', ELCANO_URL, processElcanoDataFromHtml, BACKUP_KEYS.elcano)
            ]);
            
            let allChannels = [];
            let hasFallback = false;
            let hasOnlineSuccess = false;
            results.forEach(result => {
                if (result.status === 'fulfilled' && result.value.channels) {
                    if (result.value.message.includes('historial')) {
                        hasFallback = true;
                        allChannels = allChannels.concat(result.value.channels);
                    } else {
                        allChannels = allChannels.concat(result.value.channels);
                        hasOnlineSuccess = true;
                    }
                }
            });
            
            const statusElement = document.querySelector("#tvStatusMessageContainer .status-message"); 

            if (allChannels.length > 0) {
                const newChannels = mergeChannels(allChannels);
                state.channelsData = newChannels;
                processChannelNames();
                renderTVChannels();
                cleanObsoleteRatings();
                
                if (statusElement) statusElement.remove();

                if (hasOnlineSuccess) {
                    if (hasFallback) {
                        showStatusMessage("Canales actualizados (algunos con historial).", "warning");
                    } else {
                        showStatusMessage("Canales actualizados correctamente.", "success");
                    }
                } else if (isShowingBackup) {
                    showStatusMessage("Fallo al actualizar canales. Se sigue mostrando el historial.", "error");
                } else {
                    // Usar las nuevas clases de estilo aqu√≠
                    tvChannelsGrid.innerHTML = ` <div class="no-results"><div class="no-results-icon">üì°</div><div class="no-results-text">Error al cargar los canales.</div><div class="no-results-hint">No se han conseguido cargar los canales (modo offline/sin historial).</div><button class="retry-button" onclick="loadInitialChannels()">Reintentar</button></div> `;
                    showStatusMessage("Error al cargar canales. Sin historial disponible.", "error");
                }
            } else if (isShowingBackup) {
                if (statusElement) statusElement.remove();
                showStatusMessage("Fallo al actualizar canales. Se sigue mostrando el historial.", "error");
            } else {
                if (statusElement) statusElement.remove();
                // Usar las nuevas clases de estilo aqu√≠
                tvChannelsGrid.innerHTML = ` <div class="no-results-container"><div class="no-results"><div class="no-results-icon">üì°</div><div class="no-results-text">Error al cargar los canales.</div><div class="no-results-hint">No se han conseguido cargar los canales (modo offline/sin historial).</div><button class="retry-button" onclick="loadInitialChannels()">Reintentar</button></div></div> `;
                showStatusMessage("Error al cargar canales. Sin historial disponible.", "error");
            }
        }

        function normalizeChannelName(name) {
            if (name.includes('Eurosport 1')) {
                return '‚òÖEUROSPORT 1';
            } else if (name.includes('Eurosport 2')) {
                return '‚òÖEUROSPORT 2';
            } else if (name.includes('Eurosport')) {
                return '‚òÖEUROSPORT 1';
            } else if (name.includes('Teledeporte')) {
                return 'Teledeporte';
            }
            return name;
        }

        async function loadGistChannels(infoContent) {
            return processGistData(infoContent);
        }

        async function loadEraChannels(infoContent) {
            return processGistData(infoContent).map(c => ({
                ...c,
                source: 'era',
                name: c.name
            }));
        }

        function processGistData(infoCanales) {
            const numberedChannels = [];
            const lines = infoCanales.split('\n').filter(line => line.trim() !== '');
            const channelMappings = {
                'DAZN LA LIGA 1': 'DAZN La Liga',
                'MOVISTAR': 'M+',
                'CLASICOS': 'Cl√°sicos',
                'VAMOS': 'Vamos',
                'ACCION': 'Acci√≥n',
                'LALIGA': 'La Liga',
                'DEPORTES': 'Deportes',
                'PLUS': 'Plus',
                'M.': 'M+',
                'LIGA DE CAMPEONES': 'M+ Liga de Campeones',
                'GOLF': 'Golf',
                'LA LIGA': 'La Liga',
                'HYPERMOTION': 'La Liga Hypermotion',
                'EUROSPORT': '‚òÖEUROSPORT',
                'ELLAS': 'Ellas'
            };
            for (let i = 0; i < lines.length; i += 2) {
                const nameLine = lines[i].trim();
                const idLine = lines[i + 1] ? lines[i + 1].trim() : '';
                if (nameLine.includes('-->') && idLine.length > 0) {
                    let namePart = nameLine.split('-->')[0].trim().toUpperCase();
                    const acestreamId = idLine.replace(/p$/, '');
                    if (acestreamId.length === 40) {
                        let quality = 'SD';
                        let multiAudio = false;
                        if (namePart.includes('FHD')) {
                            quality = 'FHD';
                            namePart = namePart.replace('FHD', '').trim();
                        } else if (namePart.includes('4K')) {
                            quality = '4K';
                            namePart = namePart.replace('4K', '').trim();
                        } else if (namePart.includes('HD')) {
                            quality = 'HD';
                            namePart = namePart.replace('HD', '').trim();
                        } else if (namePart.includes('SD')) {
                            quality = 'SD';
                            namePart = namePart.replace('SD', '').trim();
                        }
                        if (namePart.includes('MULTI')) {
                            multiAudio = true;
                            namePart = namePart.replace('MULTI', '').trim();
                        }
                        namePart = namePart.replace(/\(ES\)|\(Es\)/g, '', ).trim();
                        let simplifiedName = namePart;
                        for (const key in channelMappings) {
                            if (simplifiedName.includes(key)) {
                                simplifiedName = simplifiedName.replace(key, channelMappings[key]);
                            }
                        }
                        simplifiedName = normalizeChannelName(simplifiedName);
                        numberedChannels.push({
                            id: acestreamId,
                            number: acestreamId.substring(0, 3),
                            name: simplifiedName,
                            quality: quality,
                            multiAudio: multiAudio,
                            isKnown: true,
                            source: 'gist'
                        });
                        trackFirstSeen(acestreamId);
                    }
                }
            }
            return numberedChannels;
        }

        async function fetchProxyContentAndProcess(sourceName, url, processor, backupKey) {
            let lastError;
            let content = null;
            let finalMessage = '';

            for (const proxy of PROXIES) {
                try {
                    const proxyUrl = proxy + encodeURIComponent(url);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);
                    
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) throw new Error(`Proxy ${proxy} responded with ${response.status}`);
                    
                    content = await response.text();
                    
                    const contentHash = await hashContent(content);

                    const backup = loadBackup(backupKey);
                    
                    if (backup && backup.contentHash === contentHash) {
                        finalMessage = `Canales de ${sourceName} cargados (Sin cambios).`;
                        console.log(`[${sourceName}] Contenido sin cambios. Usando backup local.`);
                        return { name: sourceName, channels: backup.data, message: finalMessage };
                    } else {
                        const channels = await processor(content); 
                        saveBackup(channels, backupKey, contentHash);
                        finalMessage = `Canales de ${sourceName} cargados y actualizados.`;
                        console.log(`[${sourceName}] Contenido actualizado o nuevo. Procesado y guardado.`);
                        return { name: sourceName, channels, message: finalMessage };
                    }

                } catch (error) {
                    lastError = error;
                    console.warn(`Proxy ${proxy} fall√≥ para ${sourceName}:`, error);
                    continue;
                }
            }

            const backup = loadBackup(backupKey);
            if (backup && backup.data) {
                finalMessage = `Fallo de ${sourceName}. Mostrando canales del historial.`;
                return { name: sourceName, channels: backup.data, message: finalMessage };
            } else {
                finalMessage = `Fallo de ${sourceName}. Sin historial disponible.`;
                throw lastError || new Error(`Todos los proxies fallaron para la fuente ${sourceName}.`);
            }
        }
        
        async function loadElcanoSource(htmlContent) {
            return processElcanoDataFromHtml(htmlContent);
        }
        
        function processElcanoDataFromHtml(htmlContent) {
            const jsonMatch = htmlContent.match(/const linksData\s*=\s*({[\s\S]*?});/);
            if (!jsonMatch) throw new Error("No se encontr√≥ linksData o el formato HTML ha cambiado.");
            let jsonString = jsonMatch[1];
            jsonString = jsonString.replace(/\s*\/\/.*(?:\n|$)/g, '');
            jsonString = jsonString.replace(/,\s*}/g, '}')
                .replace(/,\s*]/g, ']');
            const linksData = JSON.parse(jsonString);
            if (!linksData || !linksData.links || !Array.isArray(linksData.links)) {
                throw new Error("Estructura de linksData incorrecta o falta el array 'links'.");
            }
            return processElcanoData(linksData.links);
        }

        async function loadEventsSource(htmlContent) {
            return processEventsData(htmlContent);
        }

        async function loadShickatChannels(htmlContent) {
            return processShickatData(htmlContent);
        }

        function processShickatData(htmlContent) {
            const numberedChannels = [];
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const cards = doc.querySelectorAll('article.canal-card');
            const nameMappings = {
                'Ellas Vamos': 'Ellas',
                'Movistar': 'M+',
                'Clasicos': 'Cl√°sicos',
                'Accion': 'Acci√≥n',
                'Deportes': 'Deportes',
                'Plus': 'Plus',
                'M+ Liga de Campeones': 'M+ Liga de Campeones',
                'Golf': 'Golf',
            };
            cards.forEach(card => {
                const nameElement = card.querySelector('.canal-nombre');
                const acestreamLinkElement = card.querySelector('.acestream-link');
                if (nameElement && acestreamLinkElement) {
                    const rawName = nameElement.textContent.trim();
                    const acestreamId = acestreamLinkElement.textContent.trim();
                    if (acestreamId.length === 40) {
                        let quality = '720p';
                        let simplifiedName = rawName;
                        if (rawName.includes('(HD)')) {
                            quality = '720p';
                            simplifiedName = rawName.replace('(HD)', '').trim();
                        } else if (rawName.includes('(FHD)')) {
                            quality = '1080p';
                            simplifiedName = simplifiedName.replace('(FHD)', '').trim();
                        }
                        const multiAudio = simplifiedName.includes('MultiAudio');
                        for (const key in nameMappings) {
                            if (simplifiedName.includes(key)) {
                                simplifiedName = simplifiedName.replace(key, nameMappings[key]);
                                break;
                            }
                        }
                        if (simplifiedName.includes('M. LaLiga')) {
                            simplifiedName = simplifiedName.replace('M. LaLiga', 'M+ La Liga');
                        } else if (simplifiedName.includes('Movistar')) {
                            simplifiedName = simplifiedName.replace('Movistar', 'M+');
                        }
                        if (simplifiedName.includes('LaLiga')) {
                            simplifiedName = simplifiedName.replace('LaLiga', 'La Liga');
                        }
                        simplifiedName = normalizeChannelName(simplifiedName);
                        numberedChannels.push({
                            id: acestreamId,
                            number: acestreamId.substring(0, 3),
                            name: simplifiedName,
                            quality: quality,
                            multiAudio: multiAudio,
                            isKnown: true,
                            source: 'shickat'
                        });
                        trackFirstSeen(acestreamId);
                    }
                }
            });
            return numberedChannels;
        }

        function processElcanoData(links) {
            const numberedChannels = [];
            const nameMap = {
                'M. LaLiga': 'M+ La Liga',
                'LaLiga Smartbank': 'La Liga Hypermotion',
                'LaLiga': 'La Liga',
                'MovistarPlus': 'M+ Plus',
                'Vamos': 'M+ Vamos',
                'Deporte': 'M+ Deportes',
                'Dedporte': 'M+ Deportes',
                'Dazn': 'DAZN',
                'Campeones': 'M+ Liga de Campeones'
            };
            links.forEach(link => {
                if (link.url && link.url.startsWith('acestream://')) {
                    const acestreamId = link.url.split('://')[1];
                    let quality = '720p';
                    let multiAudio = false;
                    if (link.name.includes('1080')) quality = '1080p';
                    if (link.name.includes('720')) quality = '720p';
                    if (link.name.includes('UHD')) quality = 'UHD';
                    multiAudio = link.name.includes('MultiAudio') || link.name.includes('Multi Audio') || link.name.toLowerCase().includes('multi');
                    let simplifiedName = link.name
                        .replace(/1080P|1080|720|UHD|MultiAudio|Multi Audio|\(.*?\)/g, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                    for (const key in nameMap) {
                        if (simplifiedName.includes(key)) {
                            simplifiedName = simplifiedName.replace(key, nameMap[key]);
                            break;
                        }
                    }
                    simplifiedName = normalizeChannelName(simplifiedName);
                    numberedChannels.push({
                        id: acestreamId,
                        number: acestreamId.substring(0, 3),
                        name: simplifiedName,
                        quality: quality,
                        multiAudio: multiAudio,
                        isKnown: true,
                        source: 'elcano'
                    });
                    trackFirstSeen(acestreamId);
                }
            });
            return numberedChannels;
        }

        function calculateDuration(sportName) {
            const normalizedName = normalizeText(sportName);
            if (normalizedName.includes('futbol')) return 120;
            if (normalizedName.includes('baloncesto') || normalizedName.includes('nba')) return 150;
            if (normalizedName.includes('tenis')) return 300;
            if (normalizedName.includes('formula 1') || normalizedName.includes('f1')) return 180;
            if (normalizedName.includes('motor')) return 120;
            if (normalizedName.includes('ciclismo')) return 180;
            if (normalizedName.includes('boxeo')) return 120;
            return 105;
        }

        function getEventTime(dateString, timeString) {
            const now = new Date();
            const date = parseDateString(dateString, now);
            if (date.getTime() === now.getTime()) {
                date.setHours(now.getHours());
                date.setMinutes(now.getMinutes());
            }
            const [hours, minutes] = timeString.split(':').map(Number);
            const eventTime = new Date(date);
            eventTime.setHours(hours, minutes, 0, 0);
            const todayYear = now.getFullYear();
            const todayMonth = now.getMonth();
            const todayDate = now.getDate();
            if (dateString.toLowerCase() === 'hoy' || (eventTime.getDate() === todayDate && eventTime.getMonth() === todayMonth && eventTime.getFullYear() === todayYear)) {
                return eventTime;
            }
            return eventTime;
        }

        function processEventsData(htmlContent) {
            const numberedChannels = [];
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const table = doc.querySelector('table');
            if (!table) {
                console.warn("No se encontr√≥ la tabla de eventos");
                return numberedChannels;
            }
            const rows = table.querySelectorAll('tbody tr');
            const channelMappings = {
                'Movistar': 'M+',
                'DAZN LA LIGA 1': 'DAZN La Liga',
                'LALIGA': 'La Liga',
                'Premier': 'Premier League',
                'Eurosport': '‚òÖEUROSPORT',
                'HYPERMOTION': 'La Liga Hypermotion',
                'LIGA DE CAMPEONES': 'M+ Liga de Campeones',
                'PLUS': 'Plus',
                'VAMOS': 'Vamos',
                'Deportes': 'Deportes'
            };
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 6) {
                    const date = cells[0].textContent.trim();
                    const time = cells[1].textContent.trim();
                    const sportName = cells[2].textContent.trim();
                    const competition = cells[3].textContent.trim();
                    const match = cells[4].textContent.trim();
                    const canalesCell = cells[5];
                    const links = canalesCell.querySelectorAll('a[href^="acestream://"]');
                    if (links.length > 0) {
                        let sportEmoji = '‚ùì';
                        const normalizedSport = normalizeText(sportName);
                        if (normalizedSport.includes('futbol')) {
                            sportEmoji = '‚öΩ';
                        } else if (normalizedSport.includes('handball') || normalizedSport.includes('handball')) {
                            sportEmoji = 'ü§æ‚Äç‚ôÇÔ∏è';
                        } else if (normalizedSport.includes('baloncesto') || normalizedSport.includes('basket') || normalizedSport.includes('nba')) {
                            sportEmoji = 'üèÄ';
                        } else if (normalizedSport.includes('tenis')) {
                            sportEmoji = 'üéæ';
                        } else if (normalizedSport.includes('motogp') || normalizedSport.includes('motos')) {
                            sportEmoji = 'üèçÔ∏è';
                        } else if (normalizedSport.includes('paddle') || normalizedSport.includes('padel')) {
                            sportEmoji = 'ü•é';
                        } else if (normalizedSport.includes('triatlon') || normalizedSport.includes('triathlon')) {
                            sportEmoji = 'üèäüö¥üèÉ';
                        } else if (normalizedSport.includes('motor') || normalizedSport.includes('rally')) {
                            sportEmoji = 'üöó';
                        } else if (normalizedSport.includes('f1') || normalizedSport.includes('formula')) {
                            sportEmoji = 'üèéÔ∏è';
                        } else if (normalizedSport.includes('boxeo') || normalizedSport.includes('lucha')) {
                            sportEmoji = 'ü•ä';
                        } else if (normalizedSport.includes('ciclismo') || normalizedSport.includes('tour')) {
                            sportEmoji = 'üö¥';
                        } else if (normalizedSport.includes('beisbol') || normalizedSport.includes('baseball')) {
                            sportEmoji = '‚öæ';
                        } else if (normalizedSport.includes('golf')) {
                            sportEmoji = '‚õ≥';
                        } else if (normalizedSport.includes('voleibol') || normalizedSport.includes('voley')) {
                            sportEmoji = 'üèê';
                        } else if (normalizedSport.includes('hockey')) {
                            sportEmoji = 'üèë';
                        } else if (normalizedSport.includes('rugby')) {
                            sportEmoji = 'üèâ';
                        } else if (normalizedSport.includes('natacion') || normalizedSport.includes('agua')) {
                            sportEmoji = 'üèä';
                        } else if (normalizedSport.includes('atletismo') || normalizedSport.includes('pista')) {
                            sportEmoji = 'üèÉ';
                        } else if (normalizedSport.includes('gimnasia')) {
                            sportEmoji = 'ü§∏';
                        } else if (normalizedSport.includes('esqui') || normalizedSport.includes('nieve')) {
                            sportEmoji = '‚õ∑Ô∏è';
                        } else if (normalizedSport.includes('surf')) {
                            sportEmoji = 'üèÑ';
                        } else if (normalizedSport.includes('e-sports') || normalizedSport.includes('esports')) {
                            sportEmoji = 'üéÆ';
                        } else if (normalizedSport.includes('ajedrez')) {
                            sportEmoji = '‚ôüÔ∏è';
                        } else if (normalizedSport.includes('dardos')) {
                            sportEmoji = 'üéØ';
                        } else if (normalizedSport.includes('billares') || normalizedSport.includes('pool')) {
                            sportEmoji = 'üé±';
                        } else if (normalizedSport.includes('patinaje') || normalizedSport.includes('roller')) {
                            sportEmoji = '‚õ∏Ô∏è';
                        } else if (normalizedSport.includes('criquet') || normalizedSport.includes('cricket')) {
                            sportEmoji = 'üèè';
                        }
                        const eventStartTime = getEventTime(date, time);
                        const durationMinutes = calculateDuration(sportName);
                        const eventEndTime = new Date(eventStartTime.getTime() + durationMinutes * 60000);
                        links.forEach(link => {
                            const acestreamId = link.href.split('://')[1];
                            let channelName = link.textContent.trim();
                            for (const key in channelMappings) {
                                const regex = new RegExp(key, 'gi');
                                channelName = channelName.replace(regex, channelMappings[key]);
                            }
                            let simplifiedName = channelName
                                .replace(/Estable|New Era II|New Loop|New Era VI|FHD|4K|HD|UHD|MultiAudio|SD|\(.*?\)|-->.*$/g, '')
                                .replace(/\s+/g, ' ')
                                .trim();
                            let quality = '720p';
                            if (channelName.includes('1080') || channelName.includes('FHD')) quality = '1080p';
                            if (channelName.includes('UHD') || channelName.includes('4K')) quality = 'UHD';
                            if (channelName.includes('SD') && !channelName.includes('FHD')) quality = 'SD';
                            const multiAudio = channelName.includes('Multi') || channelName.includes('multi');
                            simplifiedName = normalizeChannelName(simplifiedName);
                            numberedChannels.push({
                                id: acestreamId,
                                number: acestreamId.substring(0, 3),
                                name: simplifiedName,
                                quality: quality,
                                multiAudio: multiAudio,
                                isKnown: true,
                                source: 'events',
                                event: {
                                    time,
                                    competition,
                                    match,
                                    date,
                                    sportEmoji,
                                    sportName,
                                    startTime: eventStartTime.getTime(),
                                    endTime: eventEndTime.getTime()
                                }
                            });
                            trackFirstSeen(acestreamId);
                        });
                    }
                }
            });
            return numberedChannels;
        }

        function processChannelNames() {
            const brands = [{
                name: 'M+',
                class: 'movistar'
            }, {
                name: '‚òÖEurosport',
                class: 'eurosport'
            }, {
                name: 'DAZN',
                class: 'dazn'
            }, {
                name: 'F1',
                class: 'f1'
            }, {
                name: 'Acci√≥n',
                class: 'action'
            }, {
                name: 'Deportes',
                class: 'sports'
            }, {
                name: 'Cl√°sicos',
                class: 'cinema-red'
            }, {
                name: 'Vamos',
                class: 'vamos'
            }, {
                name: 'Copa del Rey',
                class: 'copadelrey'
            }, {
                name: 'Liga de Campeones',
                class: 'champions'
            }, {
                name: 'La Liga',
                class: 'liga'
            }, {
                name: 'Hypermotion',
                class: 'hypermotion'
            }, {
                name: 'Golf',
                class: 'golf'
            }, {
                name: '‚òÖEUROSPORT\\d+',
                class: 'eurosport-number',
                regex: true
            }, {
                name: 'Smartbank',
                class: 'smartbank'
            }, {
                name: 'Plus',
                class: 'plus'
            }, {
                name: 'Western',
                class: 'western'
            }, {
                name: 'Documentales',
                class: 'documentary'
            }, {
                name: 'Originales',
                class: 'originals'
            }, {
                name: 'Hits',
                class: 'cinema-red'
            }, {
                name: 'Estrenos',
                class: 'cinema-red'
            }, {
                name: 'Indie',
                class: 'cinema-red'
            }, {
                name: 'Cine Espa√±ol',
                class: 'cinema-red'
            }, {
                name: 'Drama',
                class: 'cinema-red'
            }, {
                name: 'Ellas',
                class: 'ellas'
            }, {
                name: 'Series',
                class: 'series'
            }];
            state.channelsData.forEach(channel => {
                let result = channel.name;
                brands.forEach(brand => {
                    if (brand.regex) {
                        const regex = new RegExp(`(${brand.name})`, 'gi');
                        result = result.replace(regex, `<span class="${brand.class}">$1</span>`);
                    } else {
                        const escapedName = brand.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        const regex = new RegExp(`(${escapedName})`, 'gi');
                        result = result.replace(regex, `<span class="${brand.class}">$1</span>`);
                    }
                });
                const comediaRegex = /(comedia)/gi;
                result = result.replace(comediaRegex, '<span class="degradado-comedia">Comedia</span>');
                channel.displayableName = result;
            });
        }

        function compareChannelsForSort(a, b) {
            const channelA = state.channelsData.find(c => c.id === a.id) || a;
            const channelB = state.channelsData.find(c => c.id === b.id) || b;
            
            const ratingA = state.channelRatings[channelA.id] !== undefined ? state.channelRatings[channelA.id] : 2.5;
            const ratingB = state.channelRatings[channelB.id] !== undefined ? state.channelRatings[channelB.id] : 2.5;

            if (ratingA !== ratingB) {
                return ratingB - ratingA;
            }
            
            const qualityMap = { 'UHD': 6, '4K': 5, 'FHD': 4, 'HD': 3, 'SD': 2, 'N/A': 1 };
            const qualityA = qualityMap[standardizeQuality(channelA.quality)] || 0;
            const qualityB = qualityMap[standardizeQuality(channelB.quality)] || 0;
            if (qualityB !== qualityA) {
                return qualityB - qualityA;
            }
            
            return channelA.name.localeCompare(channelB.name);
        }

        function getBestChannelInSubgroup(channels) {
            if (!channels || channels.length === 0) return null;
            
            const mainChannelName = channels[0].name.trim().toLowerCase();
            const lastPlayedId = state.lastPlayedByChannel[mainChannelName];

            if (lastPlayedId) {
                const lastPlayedChannel = channels.find(c => c.id === lastPlayedId);
                if (lastPlayedChannel) {
                    const rating = state.channelRatings[lastPlayedId] !== undefined ? state.channelRatings[lastPlayedId] : 2.5;
                    if (rating >= 3) {
                         const others = channels.filter(c => c.id !== lastPlayedId);
                         return [lastPlayedChannel, ...others].sort(compareChannelsForSort)[0];
                    }
                }
            }
            
            const sortedChannels = [...channels].sort((a, b) => {
                const ratingA = state.channelRatings[a.id] !== undefined ? state.channelRatings[a.id] : 2.5;
                const ratingB = state.channelRatings[b.id] !== undefined ? state.channelRatings[b.id] : 2.5;
                if (ratingA !== ratingB) {
                    return ratingB - ratingA;
                }
                if (a.isLive && !b.isLive) return -1;
                if (!a.isLive && b.isLive) return 1;
                const qualityMap = {
                    'UHD': 6,
                    '4K': 5,
                    'FHD': 4,
                    'HD': 3,
                    'SD': 2,
                    'N/A': 1
                };
                const qualityA = qualityMap[standardizeQuality(a.quality)] || 0;
                const qualityB = qualityMap[standardizeQuality(b.quality)] || 0;
                if (qualityB !== qualityA) {
                    return qualityB - qualityA;
                }
                const sourcePriorityMap = {
                    'gist': 4,
                    'era': 3,
                    'events': 2,
                    'shickat': 1,
                    'elcano': 0,
                    'history': -1
                };
                const sourceA = sourcePriorityMap[a.source] || 0;
                const sourceB = sourcePriorityMap[b.source] || 0;
                if (sourceB !== sourceA) {
                    return sourceB - sourceA;
                }
                return a.name.localeCompare(b.name);
            });
            return sortedChannels[0];
        }

        function getGroupedChannels() {
            const filteredChannels = filterChannels();
            const allEventChannels = state.channelsData.filter(c => c.source === 'events');
            filteredChannels.forEach(channel => {
                channel.isLive = isChannelLive(channel, allEventChannels);
            });
            const sortedChannels = [...filteredChannels].sort((a, b) => {
                if (a.isLive && !b.isLive) return -1;
                if (!a.isLive && b.isLive) return 1;
                const aIsOff = a.name.includes('(OFF)');
                const bIsOff = b.name.includes('(OFF)');
                if (aIsOff && !bIsOff) return 1;
                if (!aIsOff && bIsOff) return -1;
                const nameNumberA = getChannelNumberFromName(a.name);
                const nameNumberB = getChannelNumberFromName(b.name);
                if (nameNumberA !== nameNumberB) {
                    return nameNumberA - nameNumberB;
                }
                const qualityMap = {
                    '4K': 5,
                    'FHD': 4,
                    'HD': 3,
                    'SD': 2,
                    'N/A': 1,
                    'UHD': 6
                };
                const qualityA = qualityMap[standardizeQuality(a.quality)] || 0;
                const qualityB = qualityMap[standardizeQuality(b.quality)] || 0;
                if (qualityB !== qualityA) {
                    return qualityB - qualityA;
                }
                const sourcePriorityMap = {
                    'gist': 4,
                    'era': 3,
                    'events': 2,
                    'shickat': 1,
                    'elcano': 0,
                    'history': -1
                };
                const sourceA = sourcePriorityMap[a.source] || 0;
                const sourceB = sourcePriorityMap[b.source] || 0;
                if (sourceB !== sourceA) {
                    return sourceB - sourceA;
                }
                return a.name.localeCompare(b.name);
            });
            const groups = {};
            const eventGroupKeysByChannelName = new Map();
            sortedChannels.forEach(channel => {
                let groupName;
                let isEventGroup = false;
                if (channel.source === 'events' && channel.event) {
                    if (state.hideEventDetails) {
                        groupName = determineBrandGroup(channel);
                    } else {
                        groupName = `${channel.event.date}###${channel.event.competition}###${channel.event.match}`;
                        isEventGroup = true;
                        const normalizedChannelName = normalizeText(channel.name);
                        if (!eventGroupKeysByChannelName.has(normalizedChannelName)) {
                            eventGroupKeysByChannelName.set(normalizedChannelName, new Set());
                        }
                        eventGroupKeysByChannelName.get(normalizedChannelName).add(groupName);
                    }
                } else {
                    groupName = determineBrandGroup(channel);
                    const normalizedChannelName = normalizeText(channel.name);
                    if (!state.hideEventDetails && eventGroupKeysByChannelName.has(normalizedChannelName)) {
                        const eventGroupKeys = eventGroupKeysByChannelName.get(normalizedChannelName);
                        for (const eventGroupKey of eventGroupKeys) {
                            const eventGroup = groups[eventGroupKey];
                            if (eventGroup) {
                                eventGroup.channels.push(channel);
                                return;
                            }
                        }
                    }
                }
                if (!groups[groupName]) {
                    groups[groupName] = {
                        name: groupName,
                        channels: [],
                        isEvent: isEventGroup,
                        time: isEventGroup ? channel.event.time : null,
                        date: isEventGroup ? channel.event.date : null,
                        sportEmoji: isEventGroup ? channel.event.sportEmoji : null,
                        sportName: isEventGroup ? channel.event.sportName : null,
                        competition: isEventGroup ? channel.event.competition : null,
                        match: isEventGroup ? channel.event.match : null,
                        hasLive: channel.isLive
                    };
                } else {
                    if (channel.isLive) {
                        groups[groupName].hasLive = true;
                    }
                }
                groups[groupName].channels.push(channel);
            });
            Object.values(groups).forEach(group => {
                const subGroups = {};
                group.channels.forEach(channel => {
                    let subGroupName = channel.name.trim();
                    if (group.name === 'Otros') {
                        const normalizedChannelName = normalizeText(channel.name);
                        let foundSubGroup = null;
                        for (const subGroupKey of OTHER_SUBGROUPS) {
                            const normalizedSubGroupKey = normalizeText(subGroupKey);
                            if (normalizedChannelName.includes(normalizedSubGroupKey)) {
                                foundSubGroup = subGroupKey;
                                break;
                            }
                        }
                        subGroupName = foundSubGroup || subGroupName;
                    }
                    if (subGroupName.includes('DAZN') && subGroupName.includes('BAR')) {
                        subGroupName = subGroupName.replace(' BAR', '').trim();
                    }
                    if (!subGroups[subGroupName]) {
                        subGroups[subGroupName] = [];
                    }
                    subGroups[subGroupName].push(channel);
                });
                group.subGroups = subGroups;
            });
            const sortedGroupKeys = Object.keys(groups).sort((a, b) => {
                const groupA = groups[a];
                const groupB = groups[b];
                const aHasLive = groupA.channels.some(c => c.isLive);
                const bHasLive = groupB.channels.some(c => c.isLive);
                if (aHasLive && !bHasLive) return -1;
                if (!aHasLive && bHasLive) return 1;
                if (groupA.isEvent && groupB.isEvent) {
                    const dateCompare = compareEventDates(groupA, groupB);
                    if (dateCompare !== 0) return dateCompare;
                    return a.localeCompare(b);
                }
                if (groupA.isEvent && !groupB.isEvent) return -1;
                if (!groupA.isEvent && groupB.isEvent) return 1;
                const indexA = groupOrder.indexOf(a);
                const indexB = groupOrder.indexOf(b);
                if (indexA === -1 && indexB === -1) {
                    return a.localeCompare(b);
                }
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });
            if (groups['Otros']) {
                sortedGroupKeys.push(sortedGroupKeys.splice(sortedGroupKeys.indexOf('Otros'), 1)[0]);
            }
            return {
                groups,
                sortedGroupKeys
            };
        }

        function filterChannels() {
            let filteredChannels = state.channelsData;
            const searchTerm = state.tvSearchTerm.trim().toLowerCase();
            state.searchTerm = state.tvSearchTerm.trim();

            if (searchTerm) {
                filteredChannels = filteredChannels.filter(channel => {
                    const normalizedSearchTerm = normalizeText(searchTerm);
                    const nameMatches = normalizeText(channel.name).includes(normalizedSearchTerm);
                    const idMatches = channel.id && channel.id.toLowerCase().includes(normalizedSearchTerm.replace('#', ''));
                    let eventDetailsMatch = false;
                    if (channel.event) {
                        const {
                            time,
                            competition,
                            match,
                            date,
                            sportName
                        } = channel.event;
                        eventDetailsMatch = normalizeText(time || '').includes(normalizedSearchTerm) || normalizeText(sportName || '').includes(normalizedSearchTerm) || normalizeText(competition || '').includes(normalizedSearchTerm) || normalizeText(match || '').includes(normalizedSearchTerm) || normalizeText(date || '').includes(normalizedSearchTerm);
                    }
                    return nameMatches || idMatches || eventDetailsMatch;
                });
            }

            let currentFilter = state.tvCurrentFilter;
            let currentSportFilter = state.tvSportFilter;
            
            if (currentSportFilter !== 'all') {
                currentFilter = 'all'; 
            }

            if (currentFilter === 'favorites') {
                filteredChannels = filteredChannels.filter(c => state.favorites.includes(c.id));
            } else if (currentFilter === 'live') {
                filteredChannels = filteredChannels.filter(c => {
                    const allEventChannels = state.channelsData.filter(ch => ch.source === 'events');
                    return isChannelLive(c, allEventChannels);
                });
            } else if (currentFilter !== 'all' && currentFilter !== 'live' && currentFilter !== 'favorites') {
                filteredChannels = filteredChannels.filter(channel => normalizeText(channel.name).includes(normalizeText(currentFilter.replace('+', ''))));
            }

            if (currentSportFilter !== 'all') {
                const normalizedSportFilter = normalizeText(currentSportFilter);
                const sportSearchTerms = {
                    'futbol': ['futbol', 'soccer', 'Hypermotion', 'copa del rey', 'premier league', 'bundesliga', 'serie a'],
                    'baloncesto': ['baloncesto', 'basket', 'nba', 'euroliga'],
                    'tenis': ['tenis', 'wimbledon', 'roland garros', 'us open', 'atp', 'wta'],
                    'boxeo': ['boxeo', 'boxing', 'lucha', 'ufc', 'mma'],
                    'ciclismo': ['ciclismo', 'tour', 'giro', 'vuelta'],
                    'motorsport': ['gp', 'motogp', 'dakar', 'rally', 'wrc', 'nascar', 'motor'],
                    'f1': ['f1', 'f√≥rmula 1', 'formula 1', 'formulaone', 'f√≥rmulaone']
                };
                let targetTerms = sportSearchTerms[normalizedSportFilter] || [normalizedSportFilter];
                if (normalizedSportFilter === 'motorsport' && sportSearchTerms['f1']) {
                    targetTerms = targetTerms.concat(sportSearchTerms['f1']);
                }
                filteredChannels = filteredChannels.filter(channel => {
                    const normalizedName = normalizeText(channel.name);
                    const eventDetailsMatch = channel.event && (
                        normalizeText(channel.event.sportName || '').includes(normalizedSportFilter) ||
                        targetTerms.some(term => normalizeText(channel.event.competition || '').includes(term)) ||
                        targetTerms.some(term => normalizeText(channel.event.match || '').includes(term))
                    );
                    const nameMatch = targetTerms.some(term => normalizedName.includes(term));
                    return eventDetailsMatch || nameMatch;
                });
            }

            return filteredChannels;
        }

        function standardizeQuality(quality) {
            if (!quality) return 'SD';
            quality = quality.toLowerCase();
            if (quality.includes('uhd') || quality.includes('4k')) {
                return '4K';
            }
            if (quality.includes('1080') || quality.includes('fhd')) {
                return 'FHD';
            }
            if (quality.includes('720') || quality.includes('hd')) {
                return 'HD';
            }
            return 'SD';
        }

        function getChannelNumberFromName(name) {
            const match = name.match(/\d+/);
            return match ? parseInt(match[0], 10) : 1;
        }

        function formatEventDate(dateString) {
            const normalizedDate = dateString.toLowerCase();
            const today = new Date();

            // 1. Manejar "Hoy", "Ma√±ana", "Ayer" (Devolver solo el d√≠a)
            if (normalizedDate === 'hoy' || normalizedDate === 'ma√±ana' || normalizedDate === 'ayer') {
                const date = parseDateString(dateString, today);
                const weekdays = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
                
                // Si es "Hoy" o "Ma√±ana", devolvemos la palabra en espa√±ol para la conjugaci√≥n correcta (Eventos de Hoy)
                if (normalizedDate === 'hoy' || normalizedDate === 'ma√±ana') {
                    return normalizedDate.charAt(0).toUpperCase() + normalizedDate.slice(1);
                }
                
                // Si es "Ayer", devolvemos el d√≠a de la semana para una mejor UX
                return weekdays[date.getDay()];
            }

            // 2. Manejar formato de fecha DD/MM/YY o DD/MM/YYYY (Devolver "el [D√≠a] [fecha]")
            const parts = dateString.split('/');
            if (parts.length >= 2 && parts.length <= 3) {
                const date = parseDateString(dateString, today);
                const weekdays = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
                
                // Devuelve el d√≠a y la fecha original (ej: "el S√°bado 13/7/25")
                return `el ${weekdays[date.getDay()]} ${dateString}`; 
            }
            
            // 3. Fallback: Devolver la cadena original
            return dateString; 
        }

        function compareEventDates(eventA, eventB) {
            const today = new Date();
            const dateStringA = eventA.date.toLowerCase();
            const dateStringB = eventB.date.toLowerCase();
            
            const isTodayA = dateStringA === 'hoy';
            const isTodayB = dateStringB === 'hoy';
            const isTomorrowA = dateStringA === 'ma√±ana';
            const isTomorrowB = dateStringB === 'ma√±ana';
            const isYesterdayA = dateStringA === 'ayer';
            const isYesterdayB = dateStringB === 'ayer';
            
            if (isTodayA && !isTodayB) return -1;
            if (!isTodayA && isTodayB) return 1;
            if (isTodayA && isTodayB) return eventA.time.localeCompare(eventB.time);

            if (isTomorrowA && !isTomorrowB) return -1;
            if (!isTomorrowA && isTomorrowB) return 1;
            if (isTomorrowA && isTomorrowB) return eventA.time.localeCompare(eventB.time);
            
            if (isYesterdayA && !isYesterdayB) return -1;
            if (!isYesterdayA && isYesterdayB) return 1;
            if (isYesterdayA && isYesterdayB) return eventA.time.localeCompare(eventB.time);

            const dateA = parseDateString(eventA.date, today);
            const dateB = parseDateString(eventB.date, today);
            
            if (dateA.getTime() !== dateB.getTime()) {
                return dateA.getTime() - dateB.getTime();
            }
            return eventA.time.localeCompare(eventB.time);
        }

        function parseDateString(dateString, today) {
            const normalizedDate = dateString.toLowerCase();
            if (normalizedDate === 'ma√±ana') {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                return tomorrow;
            }
            if (normalizedDate === 'ayer') {
                const yesterday = new Date(today);
                yesterday.setDate(today.getDate() - 1);
                return yesterday;
            }
            const parts = dateString.split('/');
            if (parts.length >= 2 && parts.length <= 3) {
                // Asume formato DD/MM/YY o DD/MM/YYYY
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10) - 1; // Mes es 0-indexado
                let year = parts[2] ? parseInt(parts[2], 10) : today.getFullYear();
                
                if (parts.length === 2) {
                     year = today.getFullYear(); // Si falta el a√±o, usa el actual
                }
                
                if (year < 100) {
                     year = year + 2000;
                }
                
                const date = new Date(year, month, day);
                
                // Validaci√≥n b√°sica para evitar fechas inv√°lidas que JS pueda interpretar
                if (date.getDate() !== day || date.getMonth() !== month || date.getFullYear() !== year) {
                    return today;
                }

                return date;
            }
            return today;
        }

        function isChannelLive(channel, allEventChannels) {
            if (channel.source !== 'events' || !channel.event) {
                return false;
            }
            const now = new Date().getTime();
            const event = channel.event;
            const liveStartTime = event.startTime - (15 * 60 * 1000);
            const liveEndTime = event.endTime;
            const isTimeframeLive = now >= liveStartTime && now <= liveEndTime;
            if (!isTimeframeLive) {
                return false;
            }
            const isConflicted = findConflictingSiblings(channel, allEventChannels);
            if (isConflicted) {
                return false;
            }
            return true;
        }

        function findConflictingSiblings(currentChannel, allEventChannels) {
            const currentChannelName = normalizeText(currentChannel.name);
            const currentStartTime = currentChannel.event.startTime;
            const conflictingSibling = allEventChannels.find(sibling => {
                if (sibling.id === currentChannel.id || sibling.source !== 'events' || !sibling.event) {
                    return false;
                }
                const siblingChannelName = normalizeText(sibling.name);
                const siblingStartTime = sibling.event.startTime;
                const isSameChannelName = siblingChannelName === currentChannelName;
                const isScheduledLater = siblingStartTime > currentStartTime;
                if (isSameChannelName && isScheduledLater) {
                    const now = new Date().getTime();
                    const siblingLiveStartTime = siblingStartTime - (15 * 60 * 1000);
                    if (now >= siblingLiveStartTime) {
                        return true;
                    }
                }
                return false;
            });
            return !!conflictingSibling;
        }
        const groupOrder = [
            'DAZN F1',
            'DAZN',
            'DAZN La Liga',
            'M+ La Liga',
            'Liga de Campeones',
            'La Liga Hypermotion',
            'M+ Vamos',
            'M+ Deportes',
            'M+ Plus',
            'M+ Golf',
            'M+',
            '‚òÖEUROSPORT'
        ];
        const groupRegexes = {
            'DAZN F1': /DAZN F1/i,
            'DAZN': /DAZN(?!.*F1|.*La Liga)/i,
            'DAZN La Liga': /DAZN La Liga/i,
            'Liga de Campeones': /Liga de Campeones/i,
            'La Liga Hypermotion': /La Liga Hypermotion/i,
            'M+ La Liga': /M\+ La Liga/i,
            'M+ Vamos': /M\+ Vamos/i,
            'M+ Deportes': /M\+ Deportes/i,
            'M+ Plus': /M\+ Plus/i,
            'M+ Golf': /M\+ Golf/i,
            'M+': /M\+(?!.*La Liga|.*Vamos|.*Deportes|.*Plus|.*Golf|.*Liga de Campeones)/i,
            '‚òÖEUROSPORT': /‚òÖEUROSPORT/i,
        };

        function determineBrandGroup(channel) {
            const channelName = channel.name;
            const normalizedName = normalizeText(channelName);
            if (channelName.includes('‚òÖEUROSPORT') && channelName.includes('(')) {
                return 'Otros';
            }
            if (groupRegexes['DAZN'] && groupRegexes['DAZN'].test(channelName)) {
                if (normalizedName.includes('eventos') || normalizedName.includes('eleven')) {
                    return 'Otros';
                }
            }
            for (const groupName of groupOrder) {
                if (groupRegexes[groupName] && groupRegexes[groupName].test(channelName)) {
                    return groupName;
                }
            }
            return 'Otros';
        }

        function playChannel(acestreamId) {
            const acestreamUrl = `acestream://${acestreamId}`;
            const newWindow = window.open(acestreamUrl, '_blank');
            setTimeout(() => {
                if (newWindow && newWindow.closed) {} else {}
            }, 500);
        }

        function handleChannelPlay(channelToPlay) {
            if (state.lastChannelPlay) {
                updateChannelRating(state.lastChannelPlay.channelId, channelToPlay.id);
            }
            
            const now = new Date().getTime();
            state.lastChannelPlay = {
                channelId: channelToPlay.id,
                timestamp: now
            };
            localStorage.setItem('lastChannelPlay', JSON.stringify(state.lastChannelPlay));
            
            state.lastPlayedByChannel[channelToPlay.name.trim().toLowerCase()] = channelToPlay.id;
            localStorage.setItem('lastPlayedByChannel', JSON.stringify(state.lastPlayedByChannel));

            playChannel(channelToPlay.id);
        }

        function updateChannelRating(previousChannelId, currentChannelId) {
            const now = new Date().getTime();
            const previousChannelData = state.channelsData.find(c => c.id === previousChannelId);
            
            if (!previousChannelData) return;

            const duration = (now - state.lastChannelPlay.timestamp) / 1000;
            let rating = state.channelRatings[previousChannelId] !== undefined ? state.channelRatings[previousChannelId] : 2.5;
            let newRating = rating;
            
            const previousName = previousChannelData.name.toLowerCase().trim();
            const currentChannelData = state.channelsData.find(c => c.id === currentChannelId);
            const currentName = currentChannelData ? currentChannelData.name.toLowerCase().trim() : '';

            if (previousChannelId !== currentChannelId && previousName === currentName) {
                if (duration >= (30 * 60)) {
                    newRating += 1.5;
                } else if (duration >= (15 * 60)) {
                    newRating += 0.5;
                } else if (duration >= (5 * 60)) {
                    newRating -= 1;
                } else if (duration >= 10) {
                    newRating -= 1.5;
                } else {
                    newRating -= 2;
                }
            } else if (previousChannelId !== currentChannelId && previousName !== currentName) {
                if (duration >= (30 * 60)) {
                    newRating += 1.5;
                } else {
                    newRating = rating;
                }
            } else if (previousChannelId === currentChannelId) {
                return;
            }
            
            state.channelRatings[previousChannelId] = Math.max(1, Math.min(5, newRating));
            saveRatings();
            
            renderTVChannels();
        }

        function showCopyModal(acestreamId) {
            const acestreamUrl = `acestream://${acestreamId}`;
            const copyModal = document.getElementById('copyModal');
            const copyAceStreamBtn = document.getElementById('copyAceStreamBtn');
            const urlDisplayAceStream = document.getElementById('copyUrlDisplayAceStream');
            urlDisplayAceStream.textContent = acestreamUrl;
            copyAceStreamBtn.onclick = () => copyUrlToClipboard(acestreamUrl, 'AceStream');
            copyModal.classList.add('active');
        }

        async function copyAcestreamDirectly(acestreamId) {
            const acestreamUrl = `acestream://${acestreamId}`;
            try {
                await navigator.clipboard.writeText(acestreamUrl);
                showCopySuccessMessage('AceStream');
            } catch (err) {
                console.error('Error al copiar el texto: ', err);
                alert('No se pudo copiar la URL. Por favor, hazlo manualmente.');
            }
        }

        function hideCopyModal() {
            document.getElementById('copyModal').classList.remove('active');
        }

        function showCopySuccessMessage(format = 'AceStream') {
            const messageElement = document.getElementById('copyMessage');
            messageElement.textContent = `${format} URL copiada con √©xito!`;
            messageElement.classList.add('show');
            setTimeout(() => {
                messageElement.classList.remove('show');
            }, 2000);
        }

        async function copyUrlToClipboard(urlToCopy, format) {
            try {
                await navigator.clipboard.writeText(urlToCopy);
                hideCopyModal();
                showCopySuccessMessage(format);
            } catch (err) {
                console.error('Error al copiar el texto: ', err);
                alert('No se pudo copiar la URL. Por favor, hazlo manualmente.');
            }
        }

        function changePrimaryColor(color) {
            state.primaryColor = color;
            const rgb = hexToRgb(color);
            document.documentElement.style.setProperty('--primary-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            document.documentElement.style.setProperty('--primary', color);
            document.documentElement.style.setProperty('--primary-dark', color === '#2563eb' ? '#1e50c7' : color);
            updatePrimaryLightColor();
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.color-option[data-color="${color}"]`).classList.add('active');
            localStorage.setItem('primaryColor', color);
            renderTVChannels();
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return {
                r,
                g,
                b
            };
        }

        function updatePrimaryLightColor() {
            const rgb = hexToRgb(state.primaryColor);
            const isDarkMode = document.body.classList.contains('dark-mode');
            document.documentElement.style.setProperty('--primary-light', isDarkMode ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` : `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`);
        }

        function cleanObsoleteRatings() {
            const activeChannelIds = new Set(state.channelsData.map(c => c.id));
            const ratingsToKeep = {};
            for (const channelId in state.channelRatings) {
                if (activeChannelIds.has(channelId)) {
                    ratingsToKeep[channelId] = state.channelRatings[channelId];
                }
            }
            state.channelRatings = ratingsToKeep;
            saveRatings();
            console.log("Puntuaciones de canales obsoletas limpiadas.");
        }

        function saveRatings() {
            localStorage.setItem('channelRatings', JSON.stringify(state.channelRatings));
        }

        function resetRatings() {
            if (confirm('¬øEst√°s seguro de que quieres restablecer todas las puntuaciones de los canales?')) {
                localStorage.removeItem('channelRatings');
                state.channelRatings = {};
                renderTVChannels();
                showStatusMessage("Puntuaciones de canales restablecidas.", "success");
                document.getElementById('settingsModal').classList.remove('modal--active');
            }
        }

        function getStarRating(score) {
            const fullStars = Math.floor(score);
            const hasHalfStar = score % 1 >= 0.5;
            let stars = '‚òÖ'.repeat(fullStars);
            if (hasHalfStar) {
                stars += '<span class="half-star">‚òÖ</span>';
            }
            const emptyStars = '‚òÜ'.repeat(5 - fullStars - (hasHalfStar ? 1 : 0));
            return `<span style="color: var(--primary);">${stars}</span><span style="color: gray;">${emptyStars}</span>`;
        }

        function restoreTVFilterUI() {
            clearAllTVFilterVisuals();

            if (state.tvSportFilter !== 'all') {
                const sportBtn = document.querySelector(`.tv-nav-link[data-sport-key="${state.tvSportFilter}"]`);
                if (sportBtn) {
                    sportBtn.classList.add('tv-sidebar-link-focused');
                }
            } else {
                const brandLink = document.querySelector(`.tv-nav-link[data-filter="${state.tvCurrentFilter}"]`);
                if (brandLink) {
                    brandLink.classList.add('tv-sidebar-link-focused');
                }
            }
        }
        
        const createTVChannelCard = (channel, allOptionsJson = '[]') => {
            const logoInfo = getPlaceholderInfo(channel.name);
            const isLiveClass = '';
            let bgColor = 'var(--card-bg)';
            let backgroundImageStyle = '';
            let logoClass = '';
            let nameStyle = 'white';

            let channelNameHTML = `<h3 style="font-size: 0.6rem; font-weight: 700; color: ${nameStyle}; white-space: normal; text-align: center;">${channel.displayableName}</h3>`;

            let liveIndicator = '';
            if (channel.isLive) {
                liveIndicator = `<span style="color: var(--primary); font-weight: 700; animation: soft-blink 1.5s infinite ease-in-out;">üî¥ EN VIVO</span>`;
            }

            if (logoInfo) {
                const fullUrl = LOGOPEDIA_BASE_URL + logoInfo.url;
                const proxiedUrl = proxyImage(fullUrl);
                backgroundImageStyle = `background-image: url('${proxiedUrl}');`;
                logoClass = logoInfo.class;

                channelNameHTML = `<h3 style="font-size: 0.6rem; font-weight: 700; color: ${nameStyle}; white-space: normal; text-align: center; opacity: 0;">${channel.displayableName}</h3>`;
                
            } else {
                if (channel.name.includes('DAZN') && !channel.name.includes('F1')) bgColor = '#353535';
                else if (channel.name.includes('DAZN F1')) bgColor = '#353535';
                else if (channel.name.includes('M+')) bgColor = '#0085C1';
                else if (channel.name.includes('EUROSPORT')) bgColor = '#5e17eb';
                backgroundImageStyle = `background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%), ${bgColor};`;

                channelNameHTML = `<div style="position: absolute; bottom: 5px; left: 5px; right: 5px; text-align: center;"><h3 style="font-size: 0.6rem; font-weight: 700; color: ${nameStyle}; white-space: normal; margin: 0;">${channel.displayableName}</h3></div>`;
            }

            const rating = state.channelRatings[channel.id] !== undefined ? state.channelRatings[channel.id] : 2.5;
            const ratingStars = getStarRating(rating);
            const optionsButton = `<button class="tv-link-button" data-channel-id="${channel.id}" title="Ver opciones alternativas">+</button>`;

            return ` <div class="tv-card ${isLiveClass} ${logoClass}" data-channel-id="${channel.id}" data-all-options='${allOptionsJson}' style="${backgroundImageStyle}" tabindex="0" role="button" aria-label="Ver canal ${channel.name}"> ${optionsButton} ${channelNameHTML}</div> `;
        };

        function createTVChannelsHTML(groups, sortedGroupKeys) {
            if (sortedGroupKeys.length === 0) {
                // Nuevo HTML para el mensaje de no resultados, envuelto en el nuevo div para centrar
                return `
                    <div class="no-results-container">
                        <div class="no-results">
                            <div class="no-results-icon">üì°</div>
                            <div class="no-results-text">No se encontraron canales</div>
                            <div class="no-results-hint">Prueba con otros filtros o t√©rminos de b√∫squeda</div>
                        </div>
                    </div>
                `;
            }
            
            let html = '';
            let lastDateRendered = null;
            for (const groupKey of sortedGroupKeys) {
                const group = groups[groupKey];
                const subGroups = group.subGroups;

                if (group.isEvent) {
                    const formattedDate = formatEventDate(group.date);
                    
                    if (formattedDate !== lastDateRendered) {
                        
                        let prefix = 'Eventos del ';
                        const firstWord = formattedDate.split(' ')[0].toLowerCase();
                        
                        // Si empieza por Hoy, Ma√±ana, o Ayer, usamos "Eventos de"
                        if (firstWord === 'hoy' || firstWord === 'ma√±ana' || firstWord === 'ayer' || firstWord === 'el') {
                            prefix = 'Eventos de ';
                        }

                        // Construimos el encabezado con el prefijo
                        html += `<h2 class="tv-date-header">${prefix}${formattedDate}</h2>`;
                        lastDateRendered = formattedDate;
                    }
                } else {
                    lastDateRendered = null;
                }

                let groupTitle = group.name;
                let groupTitleStyle = '';
                
                if (group.isEvent) {
                    const liveTimeClass = group.hasLive ? 'live-time-blink' : '';
                    groupTitle = `<span class="${liveTimeClass}" style="margin-right: 7.5px;">${group.time}</span> ${group.sportEmoji} ${group.competition} - ${group.match}`;
                    
                    const isFirstGroupAfterDateHeader = !lastDateRendered || (group.date && formatEventDate(group.date) === lastDateRendered);
                    if(isFirstGroupAfterDateHeader) {
                        groupTitleStyle = 'margin-top: 0;';
                    }

                }

                html += ` <div class="tv-group"><header class="tv-group-header"><h2 class="tv-group-title" style="${groupTitleStyle}">${groupTitle}</h2></header> `;

                let cardsHTML = '';
                const sortedSubGroupNames = Object.keys(subGroups).sort((a, b) => {
                    const aHasLive = subGroups[a].some(c => c.isLive);
                    const bHasLive = subGroups[b].some(c => c.isLive);
                    if (aHasLive && !bHasLive) return -1;
                    if (!aHasLive && bHasLive) return 1;
                    return a.localeCompare(b);
                });

                sortedSubGroupNames.forEach(subGroupName => {
                    const channels = subGroups[subGroupName];
                    const bestChannel = getBestChannelInSubgroup(channels);
                    if (!bestChannel) return;

                    const allOptions = channels.map(c => ({
                        id: c.id,
                        name: c.displayableName,
                        quality: standardizeQuality(c.quality),
                        multiAudio: c.multiAudio,
                        source: c.source,
                        rating: state.channelRatings[c.id] !== undefined ? state.channelRatings[c.id] : 2.5
                    }));
                    const allOptionsJson = JSON.stringify(allOptions);

                    cardsHTML += createTVChannelCard(bestChannel, allOptionsJson);
                });

                if (cardsHTML) {
                    html += `<div class="tv-subgroup-content">${cardsHTML}</div>`;
                }

                html += `</div>`;
            }
            return html;
        }

        function renderTVChannels() {
            const tvGrid = document.getElementById('tvChannelsGrid');
            if (!tvGrid) return;

            const statusContainer = document.getElementById('tvStatusMessageContainer');
            if (statusContainer) {
                statusContainer.innerHTML = ''; 
            }

            const previouslyFocusedElement = state.tvFocusManager ? state.tvFocusManager.currentFocus : null;

            restoreTVFilterUI();

            const {
                groups,
                sortedGroupKeys
            } = getGroupedChannels();
            tvGrid.innerHTML = createTVChannelsHTML(groups, sortedGroupKeys);
            
            // A√±adir/eliminar la clase de centrado si no hay canales
            if (sortedGroupKeys.length === 0) {
                tvGrid.classList.add('no-channels');
            } else {
                tvGrid.classList.remove('no-channels');
            }
            
            attachTVCardEvents();

            if (state.tvFocusManager) {
                state.tvFocusManager.updateFocusableElements();

                const tvSearch = document.getElementById('tvSearch');
                if (previouslyFocusedElement === tvSearch || (tvSearch && document.activeElement === tvSearch)) {
                    state.tvFocusManager.setFocus(tvSearch);
                    return;
                }

                if (previouslyFocusedElement && document.body.contains(previouslyFocusedElement)) {
                    state.tvFocusManager.setFocus(previouslyFocusedElement);
                    return;
                }

                let elementToFocus = null;
                const activeSportFilterLink = document.querySelector(`.tv-nav-link.sport-filter.tv-sidebar-link-focused`);
                const activeBrandLink = document.querySelector(`.tv-nav-link.brand-filter[data-filter="${state.tvCurrentFilter}"].tv-sidebar-link-focused`);
                const activeMainLink = document.querySelector(`.tv-nav-link[data-filter="${state.tvCurrentFilter}"].tv-sidebar-link-focused`);

                elementToFocus = activeSportFilterLink || activeBrandLink || activeMainLink;

                if (elementToFocus) {
                    state.tvFocusManager.setFocus(elementToFocus);
                } else {
                    state.tvFocusManager.setFocus(document.querySelector('.tv-nav-link[data-filter="all"]'));
                }
            }
        }
        const attachTVCardEvents = () => {
            const cards = document.querySelectorAll('.tv-card');
            cards.forEach(card => {
                card.removeEventListener('click', handleTVCardPlay);
                card.addEventListener('click', handleTVCardPlay);
                const optionsButton = card.querySelector('.tv-link-button');
                // IMPORTANTE: Aseguramos que el evento del bot√≥n SIEMPRE est√© asociado
                if (optionsButton) {
                    optionsButton.removeEventListener('click', handleTVCardOptionsClick);
                    optionsButton.addEventListener('click', handleTVCardOptionsClick);
                }
                
                // Si el bot√≥n est√° oculto, asociamos el evento de opciones al clic de la tarjeta, 
                // pero S√ìLO si el clic no es un "play" normal (e.g., el clic en la esquina inferior derecha)
                if (state.hideOptionsButton) {
                    card.removeEventListener('auxiliaryclick', handleTVCardOptionsClick);
                    // Usamos un nombre de evento auxiliar o una comprobaci√≥n de coordenadas, 
                    // pero para simplificar y cumplir con el requisito de "sigue funcionando si pulsas" en el √°rea del bot√≥n:
                    // Dejamos que el clic principal dispare play (handleTVCardPlay)
                    // y la funcionalidad del bot√≥n la asociamos con un clic secundario (por ejemplo, doble clic o clic derecho, si no us√°ramos un control remoto).
                    // Para el prop√≥sito del TV-Mode (navegaci√≥n con flechas/Enter), el bot√≥n sigue siendo seleccionable, y el clic principal de la tarjeta es para "Play".
                    
                    // Si el requisito es que la tarjeta haga Play en cualquier lado, pero el clic **en el √°rea del bot√≥n** abra las opciones:
                    // Necesitar√≠amos una l√≥gica de coordenadas. Para el modo TV, lo m√°s sencillo es que el **Enter** en la tarjeta haga Play, y un **bot√≥n dedicado** haga Opciones.
                    // Ya que el bot√≥n existe (`.tv-link-button`), y se hace invisible con CSS, si el bot√≥n tiene un `click` listener, este se disparar√° si el usuario logra hacer clic exactamente en el √°rea *invisible* del bot√≥n.

                    // La soluci√≥n m√°s simple y robusta para este caso de uso (bot√≥n invisible con funcionalidad) es dejar que el evento del bot√≥n se capture *solamente* por el bot√≥n.
                    // Si el usuario hace clic en el √°rea visible de la tarjeta, se dispara `handleTVCardPlay`.
                    // Si el usuario logra hacer clic exactamente en el √°rea invisible del bot√≥n, se dispara `handleTVCardOptionsClick` (porque el bot√≥n tiene `visibility: hidden`, no `display: none`).

                    // Ya que `handleTVCardPlay` tiene `if (e.target.closest('.tv-link-button')) { return; }`, 
                    // si el bot√≥n es clicado, el evento se propaga al bot√≥n, se dispara `handleTVCardOptionsClick`, y `handleTVCardPlay` se detiene.
                    
                    // Con `visibility: hidden` aplicado por CSS, la funcionalidad es correcta sin m√°s cambios en JS.
                }
            });
        };
        
        const handleTVCardPlay = (e) => {
            if (e.target.closest('.tv-link-button')) {
                // Si se hace clic en el bot√≥n de opciones, no hacer play
                return;
            }
            const card = e.currentTarget;
            const channelId = card.getAttribute('data-channel-id');
            const channel = state.channelsData.find(c => c.id === channelId);
            
            if (!channel) return;
            
            const optionsJson = card.getAttribute('data-all-options');
            let allOptions = [];
            try {
                allOptions = JSON.parse(optionsJson);
            } catch (error) {
                console.error("Error al parsear opciones para TV Card:", error);
                handleChannelPlay(channel);
                return;
            }
            
            const now = new Date().getTime();
            const RECENT_FAILURE_THRESHOLD_MS = 40 * 60 * 1000; 
            let channelToPlay = channel;
            let statusMessage = '';
            
            if (state.lastChannelPlay && 
                state.lastChannelPlay.channelId === channel.id && 
                (now - state.lastChannelPlay.timestamp) < RECENT_FAILURE_THRESHOLD_MS) {
                
                const sortedOptions = allOptions
                    .map(opt => state.channelsData.find(c => c.id === opt.id))
                    .filter(c => c)
                    .sort(compareChannelsForSort);
                
                const alternativeChannel = sortedOptions[1]; 
                
                if (alternativeChannel) {
                    channelToPlay = alternativeChannel;
                    
                    statusMessage = `‚ùå Fallo detectado en ${channel.name}. Abriendo alternativa: ${alternativeChannel.name} (${standardizeQuality(alternativeChannel.quality)}).`;
                    showStatusMessage(statusMessage, 'error');
                    
                } else {
                    statusMessage = `‚ö†Ô∏è ${channel.name} ha fallado de nuevo. Sin alternativas. Reintentando...`;
                    showStatusMessage(statusMessage, 'warning');
                }
            } 

            handleChannelPlay(channelToPlay);
        }
        
        const handleTVCardOptionsClick = (e) => {
            e.stopPropagation();
            const card = e.currentTarget.closest('.tv-card');
            const channelId = card.getAttribute('data-channel-id');
            const optionsJson = card.getAttribute('data-all-options');
            const channel = state.channelsData.find(c => c.id === channelId);
            if (channel && optionsJson) {
                try {
                    const allOptions = JSON.parse(optionsJson);
                    showTvOptionsModal(channel.name, allOptions);
                } catch (error) {
                    console.error("Error al parsear las opciones del canal:", error);
                    handleChannelPlay(channel);
                }
            }
        };

        function showTvOptionsModal(mainChannelName, optionsList) {
            const modal = document.getElementById('tvChannelOptionsModal');
            const nameSpan = document.getElementById('tvModalChannelName');
            const listDiv = document.getElementById('tvModalChannelList');
            nameSpan.innerHTML = state.channelsData.find(c => c.name === mainChannelName)?.displayableName || mainChannelName;
            listDiv.innerHTML = '';
            
            const lastPlayedId = state.lastPlayedByChannel[mainChannelName.trim().toLowerCase()];

            const renderOptionItem = (option) => {
                const isFavorite = state.favorites.includes(option.id);
                const favoriteIcon = isFavorite ? '‚òÖ' : '‚òÜ';
                const favoriteClass = isFavorite ? 'is-favorite' : 'is-not-favorite';
                
                const isLastViewed = option.id === lastPlayedId;
                const lastViewedIndicator = isLastViewed ? '<span class="last-viewed-indicator" title="√öltimo AceStream reproducido para este canal">üëÅÔ∏è</span>' : '';
                
                const ratingStars = getStarRating(option.rating);
                let sourceBadgeText = '';
                let sourceBadgeClass = '';
                switch (option.source) {
                    case 'gist':
                        sourceBadgeClass = 'gist-badge';
                        sourceBadgeText = 'NE';
                        break;
                    case 'era':
                        sourceBadgeClass = 'era-badge';
                        sourceBadgeText = 'ER';
                        break;
                    case 'elcano':
                        sourceBadgeClass = 'elcano-badge';
                        sourceBadgeText = 'EC';
                        break;
                    case 'events':
                        sourceBadgeClass = 'events-badge';
                        sourceBadgeText = 'EV';
                        break;
                    case 'shickat':
                        sourceBadgeClass = 'shickat-badge';
                        sourceBadgeText = 'SH';
                        break;
                }
                const sourceBadge = `<span class="${sourceBadgeClass}" style="font-size: 0.35rem; font-weight: 700; padding: 1px 2.5px; border-radius: 1.5px; color: white;">${sourceBadgeText}</span>`;
                
                const item = document.createElement('div');
                item.className = 'channel-option-item';
                item.setAttribute('data-id', option.id);
                const channelDisplayName = option.name;
                
                item.innerHTML = `
                    <div class="channel-option-name-container">
                        <button class="favorite-toggle-btn ${favoriteClass}" data-id="${option.id}" title="Marcar como favorito">${favoriteIcon}</button>
                        ${lastViewedIndicator}
                        <span class="channel-option-name">${channelDisplayName}</span>
                    </div>
                    <div class="channel-option-details">
                        ${ratingStars}
                        ${option.quality}
                        ${option.multiAudio ? 'üéß' : ''}
                        <span class="channel-number-display" style="font-weight: 700; color: var(--channel-number-color);">${option.id.substring(0, 3)}</span>
                        ${sourceBadge}
                    </div>
                `;

                item.onclick = (e) => {
                    if (e.target.closest('.favorite-toggle-btn')) {
                        return;
                    }
                    const fullChannel = state.channelsData.find(c => c.id === option.id);
                    if (fullChannel) {
                        handleChannelPlay(fullChannel);
                    }
                    hideTvOptionsModal();
                };

                item.querySelector('.favorite-toggle-btn').addEventListener('click', function(e) {
                    e.stopPropagation();
                    const channelIdToToggle = this.getAttribute('data-id');
                    
                    toggleFavorite(channelIdToToggle); 
                    
                    const isNowFavorite = state.favorites.includes(channelIdToToggle);
                    this.textContent = isNowFavorite ? '‚òÖ' : '‚òÜ';
                    this.classList.toggle('is-favorite', isNowFavorite);
                    this.classList.toggle('is-not-favorite', !isNowFavorite);
                    
                    showStatusMessage(`Canal ${isNowFavorite ? 'a√±adido' : 'eliminado'} de favoritos.`, 'info');
                    
                });
                
                listDiv.appendChild(item);
            };

            optionsList
                .map(option => {
                    const channel = state.channelsData.find(c => c.id === option.id);
                    const rating = channel ? (state.channelRatings[channel.id] || 2.5) : 2.5;
                    const qualityMap = { 'UHD': 6, '4K': 5, 'FHD': 4, 'HD': 3, 'SD': 2, 'N/A': 1 };
                    const qualityScore = channel ? (qualityMap[standardizeQuality(channel.quality)] || 0) : 0;
                    
                    return { ...option, rating, qualityScore, isLastViewed: option.id === lastPlayedId };
                })
                .sort((a, b) => {
                    if (a.isLastViewed && !b.isLastViewed) return -1;
                    if (!a.isLastViewed && b.isLastViewed) return 1;
                    
                    if (b.rating !== a.rating) return b.rating - a.rating;
                    
                    if (b.qualityScore !== a.qualityScore) return b.qualityScore - a.qualityScore;
                    
                    return a.name.localeCompare(b.name);
                })
                .forEach(renderOptionItem);


            modal.classList.add('modal--active');
        }

        function hideTvOptionsModal() {
            document.getElementById('tvChannelOptionsModal').classList.remove('modal--active');
        }

        function initializeTVNavigation() {
            if (state.tvFocusManager) {
                document.removeEventListener('keydown', state.tvFocusManager.handleKeyDown);
            }
            const tvNavigation = {
                currentFocus: null,
                focusableElements: [],
                init: function() {
                    this.updateFocusableElements();
                    if (document.activeElement.id === 'tvSearch') {
                        this.setFocus(document.getElementById('tvSearch'));
                    } else if (this.focusableElements.length > 0) {
                        this.setFocus(document.querySelector('.tv-nav-link[data-filter="all"]'));
                    }
                    this.handleKeyDown = this.handleKeyDown.bind(this);
                    document.addEventListener('keydown', this.handleKeyDown);
                },
                removeFocusClasses: function() {
                    document.querySelectorAll('.tv-card-focused').forEach(el => el.classList.remove('tv-card-focused'));
                    document.querySelectorAll('.tv-sidebar-link-focused').forEach(el => el.classList.remove('tv-sidebar-link-focused'));
                },
                updateFocusableElements: function() {
                    const searchElement = document.getElementById('tvSearch');
                    const sidebarLinks = Array.from(document.querySelectorAll('.tv-nav-link'));
                    const allCards = Array.from(document.querySelectorAll('.tv-card'));
                    const settingsModeBtn = document.getElementById('settingsModeBtn');
                    this.focusableElements = [searchElement, ...sidebarLinks, settingsModeBtn, ...allCards].filter(el => el && el.offsetParent !== null);
                },
                setFocus: function(element) {
                    if (!element) return;
                    this.removeFocusClasses();
                    this.currentFocus = element;
                    
                    if (element.id === 'tvSearch') {
                        element.focus();
                    } 
                    else if (element.id === 'settingsModeBtn') {
                        element.focus();
                        element.classList.add('tv-sidebar-link-focused');
                    }
                    else {
                        element.focus();
                        element.classList.add(element.classList.contains('tv-card') ? 'tv-card-focused' : 'tv-sidebar-link-focused');
                    }
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'center'
                    });
                },
                handleKeyDown: function(e) {
                    let nextElement = null;
                    switch (e.key) {
                        case 'ArrowUp':
                        case 'ArrowDown':
                        case 'ArrowLeft':
                        case 'ArrowRight':
                            e.preventDefault();
                            nextElement = this.moveFocus(e.key);
                            break;
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            this.selectFocused();
                            return;
                        case 'Escape':
                        case 'Backspace':
                            e.preventDefault();
                            if (document.getElementById('settingsModal').classList.contains('modal--active')) {
                                document.getElementById('settingsModal').classList.remove('modal--active');
                                return;
                            }
                            if (document.getElementById('tvChannelOptionsModal').classList.contains('modal--active')) {
                                hideTvOptionsModal();
                                return;
                            }
                            if (this.currentFocus.id === 'tvSearch' && this.currentFocus.value.length > 0) {
                                this.currentFocus.value = '';
                                state.tvSearchTerm = '';
                                renderTVChannels();
                                return;
                            }
                            if (this.currentFocus.classList.contains('tv-card') || this.currentFocus.classList.contains('tv-nav-link')) {
                                applyTVFilter('all', 'brand');
                                this.setFocus(document.querySelector('.tv-nav-link[data-filter="all"]'));
                                return;
                            }
                            
                            if (this.currentFocus === document.querySelector('.tv-nav-link[data-filter="all"]')) {
                                this.setFocus(document.getElementById('tvSearch'));
                                return;
                            }
                            
                            if (this.currentFocus.id === 'settingsModeBtn') {
                                this.setFocus(document.querySelector('.tv-nav-link[data-filter="all"]'));
                                return;
                            }
                            
                            return;
                    }
                    if (nextElement) {
                        this.setFocus(nextElement);
                    }
                },
                moveFocus: function(direction) {
                    this.updateFocusableElements();
                    const allCards = Array.from(document.querySelectorAll('.tv-card'));
                    const sidebarElements = Array.from(document.querySelectorAll('#tvSearch, .tv-nav-link, #settingsModeBtn'));
                    const focusedIndex = sidebarElements.indexOf(this.currentFocus);

                    if (sidebarElements.includes(this.currentFocus)) {
                        if (direction === 'ArrowDown' && focusedIndex < sidebarElements.length - 1) {
                            return sidebarElements[focusedIndex + 1];
                        } else if (direction === 'ArrowUp' && focusedIndex > 0) {
                            return sidebarElements[focusedIndex - 1];
                        } else if (direction === 'ArrowRight' && allCards.length > 0) {
                            return allCards[0];
                        }
                    }
                    else if (allCards.includes(this.currentFocus)) {
                        const currentRow = this.currentFocus.closest('.tv-subgroup-content');
                        if (!currentRow) return null;
                        const cardsInCurrentRow = Array.from(currentRow.querySelectorAll('.tv-card'));
                        const indexInRow = cardsInCurrentRow.indexOf(this.currentFocus);
                        const allRows = Array.from(document.querySelectorAll('.tv-subgroup-content'));
                        const currentRowIndex = allRows.indexOf(currentRow);

                        if (direction === 'ArrowRight') {
                            if (indexInRow < cardsInCurrentRow.length - 1) {
                                return cardsInCurrentRow[indexInRow + 1];
                            }
                        } else if (direction === 'ArrowLeft') {
                            if (indexInRow > 0) {
                                return cardsInCurrentRow[indexInRow - 1];
                            } else {
                                return document.getElementById('settingsModeBtn');
                            }
                        } else if (direction === 'ArrowDown') {
                            if (currentRowIndex < allRows.length - 1) {
                                const nextRow = allRows[currentRowIndex + 1];
                                const cardsInNextRow = Array.from(nextRow.querySelectorAll('.tv-card'));
                                return cardsInNextRow[Math.min(indexInRow, cardsInNextRow.length - 1)];
                            }
                        } else if (direction === 'ArrowUp') {
                            if (currentRowIndex > 0) {
                                const prevRow = allRows[currentRowIndex - 1];
                                const cardsInPrevRow = Array.from(prevRow.querySelectorAll('.tv-card'));
                                return cardsInPrevRow[Math.min(indexInRow, cardsInPrevRow.length - 1)];
                            } else {
                                return null;
                            }
                        }
                    }
                    return null;
                },
                selectFocused: function() {
                    if (this.currentFocus) {
                        if (this.currentFocus.classList.contains('tv-card')) {
                            this.currentFocus.click();
                        } else if (this.currentFocus.classList.contains('tv-nav-link')) {
                            this.currentFocus.click();
                        } else if (this.currentFocus.id === 'tvSearch') {
                            this.currentFocus.focus();
                        } else if (this.currentFocus.id === 'settingsModeBtn') {
                            document.getElementById('settingsModal').classList.add('modal--active');
                            setTimeout(() => {
                                document.getElementById('closeSettingsBtn').focus();
                            }, 100);
                        }
                    }
                }
            };
            state.tvFocusManager = tvNavigation;
            tvNavigation.init();
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.body.classList.add('dark-mode');
            document.body.classList.add('tv-mode-active');
            
            // Inicializaci√≥n del nuevo ajuste
            document.body.classList.toggle('hide-options-button-active', state.hideOptionsButton);
            
            initializeTVNavigation();
            loadInitialChannels();

            document.getElementById('darkModeCheckbox').checked = state.darkMode;
            document.getElementById('hideEventDetailsCheckbox').checked = state.hideEventDetails;
            document.getElementById('fullScreenOnClickCheckbox').checked = state.fullScreenOnClick; 
            document.getElementById('hideOptionsButtonCheckbox').checked = state.hideOptionsButton; // Establecer estado inicial del nuevo switch
            document.body.classList.toggle('hide-event-details', state.hideEventDetails);
            
            const copyModal = document.getElementById('copyModal');
            const cancelCopyBtn = document.getElementById('cancelCopyBtn');
            cleanupOldFirstSeenRecords();
            
            if (cancelCopyBtn) {
                cancelCopyBtn.addEventListener('click', hideCopyModal);
            }
            document.getElementById('closeTvOptionsBtn').addEventListener('click', hideTvOptionsModal);
            window.addEventListener('click', (event) => {
                if (event.target === copyModal) {
                    hideCopyModal();
                }
            });
            
            // Event Listener de Pantalla Completa al Clic
            document.body.addEventListener('click', (e) => {
                if (state.fullScreenOnClick && 
                    !e.target.closest('.modal') && 
                    !e.target.closest('#tvSidebar') &&
                    e.target.id !== 'tvSearch') {
                    requestFullScreen();
                }
            });
            
            document.getElementById('settingsModeBtn').addEventListener('click', () => {
                document.getElementById('settingsModal').classList.add('modal--active');
            });

            document.querySelectorAll('#tvSidebar .tv-nav-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (TV_BRAND_FILTER_KEYS.includes(this.dataset.filter)) {
                        applyTVFilter(this.dataset.filter, 'brand');
                    } else if (TV_SPORT_FILTER_KEYS.includes(this.dataset.sportKey)) {
                        applyTVFilter(this.dataset.sportKey, 'sport');
                    }
                    if (state.tvFocusManager) {
                        state.tvFocusManager.setFocus(this);
                    }
                });
            });

            let tvSearchTimeout;
            document.getElementById('tvSearch').addEventListener('input', function(e) {
                clearTimeout(tvSearchTimeout);
                tvSearchTimeout = setTimeout(() => {
                    state.tvSearchTerm = e.target.value;
                    renderTVChannels();
                }, 300);
            });

            document.getElementById('darkModeCheckbox').addEventListener('change', toggleDarkMode);
            document.getElementById('hideEventDetailsCheckbox').addEventListener('change', toggleHideEventDetails);
            document.getElementById('fullScreenOnClickCheckbox').addEventListener('change', toggleFullScreenOnClick); 
            // NUEVO EVENT LISTENER para el nuevo switch
            document.getElementById('hideOptionsButtonCheckbox').addEventListener('change', toggleHideOptionsButton); 
            
            document.getElementById('closeSettingsBtn').addEventListener('click', () => document.getElementById('settingsModal').classList.remove('modal--active'));
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.addEventListener('click', () => changePrimaryColor(btn.dataset.color));
            });
            changePrimaryColor(state.primaryColor);
            
            document.addEventListener('click', (e) => {
                if (e.target.closest('.channel-number-badge-button')) {
                    const button = e.target.closest('.channel-number-badge-button');
                    e.stopPropagation();
                    const channelId = button.dataset.id;
                    copyAcestreamDirectly(channelId);
                }
            });
            
            setInterval(() => {
                renderTVChannels();
            }, 60000);
        });
    </script>
</body>

</html>
